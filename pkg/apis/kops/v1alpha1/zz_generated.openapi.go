// +build !ignore_autogenerated

/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1alpha1

import (
	spec "github.com/go-openapi/spec"
	common "k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AccessSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "AccessSpec provides configuration details related to kubeapi dns and ELB access",
					Properties: map[string]spec.Schema{
						"dns": {
							SchemaProps: spec.SchemaProps{
								Description: "DNS will be used to provide config on kube-apiserver elb dns",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.DNSAccessSpec"),
							},
						},
						"loadBalancer": {
							SchemaProps: spec.SchemaProps{
								Description: "LoadBalancer is the configuration for the kube-apiserver ELB",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.LoadBalancerAccessSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.DNSAccessSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.LoadBalancerAccessSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AddonSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "AddonSpec defines an addon that we want to install in the cluster",
					Properties: map[string]spec.Schema{
						"manifest": {
							SchemaProps: spec.SchemaProps{
								Description: "Manifest is a path to the manifest that defines the addon",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AlwaysAllowAuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AmazonVPCNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "AmazonVPCNetworkingSpec declares that we want Amazon VPC CNI networking",
					Properties: map[string]spec.Schema{
						"imageName": {
							SchemaProps: spec.SchemaProps{
								Description: "The container image name to use, which by default is: 602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon-k8s-cni:1.0.0",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.Assets": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Assets defined the privately hosted assets",
					Properties: map[string]spec.Schema{
						"containerRegistry": {
							SchemaProps: spec.SchemaProps{
								Description: "ContainerRegistry is a url for to a docker registry",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"fileRepository": {
							SchemaProps: spec.SchemaProps{
								Description: "FileRepository is the url for a private file serving repository",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"containerProxy": {
							SchemaProps: spec.SchemaProps{
								Description: "ContainerProxy is a url for a pull-through proxy of a docker registry",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AuthenticationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kopeio": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KopeioAuthenticationSpec"),
							},
						},
						"aws": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AwsAuthenticationSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.AwsAuthenticationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.KopeioAuthenticationSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"alwaysAllow": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AlwaysAllowAuthorizationSpec"),
							},
						},
						"rbac": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.RBACAuthorizationSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.AlwaysAllowAuthorizationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.RBACAuthorizationSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.AwsAuthenticationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.BastionSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"enable": {
							SchemaProps: spec.SchemaProps{
								Description: "Controls if a private topology should deploy a bastion host or not The bastion host is designed to be a simple, and secure bridge between the public subnet and the private subnet",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"machineType": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"name": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"idleTimeout": {
							SchemaProps: spec.SchemaProps{
								Description: "IdleTimeout is the bastion's Loadbalancer idle timeout",
								Type:        []string{"integer"},
								Format:      "int64",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.CNINetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "CNINetworkingSpec is the specification for networking that is implemented by a Daemonset Networking is not managed by kops - we can create options here that directly configure e.g. weave but this is useful for arbitrary network modes or for modes that don't need additional configuration.",
					Properties: map[string]spec.Schema{
						"usesSecondaryIP": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.CalicoNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "CalicoNetworkingSpec declares that we want Calico networking",
					Properties: map[string]spec.Schema{
						"crossSubnet": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"logSeverityScreen": {
							SchemaProps: spec.SchemaProps{
								Description: "LogSeverityScreen lets us set the desired log level. (Default: info)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"mtu": {
							SchemaProps: spec.SchemaProps{
								Description: "MTU to be set in the cni-network-config for calico.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"prometheusMetricsEnabled": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusMetricsEnabled can be set to enable the experimental Prometheus metrics server (default: false)",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"prometheusMetricsPort": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusMetricsPort is the TCP port that the experimental Prometheus metrics server should bind to (default: 9091)",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"prometheusGoMetricsEnabled": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusGoMetricsEnabled enables Prometheus Go runtime metrics collection",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"prometheusProcessMetricsEnabled": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusProcessMetricsEnabled enables Prometheus process metrics collection",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.CanalNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "CanalNetworkingSpec declares that we want Canal networking",
					Properties: map[string]spec.Schema{
						"chainInsertMode": {
							SchemaProps: spec.SchemaProps{
								Description: "ChainInsertMode controls whether Felix inserts rules to the top of iptables chains, or appends to the bottom. Leaving the default option is safest to prevent accidentally breaking connectivity. Default: 'insert' (other options: 'append')",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"defaultEndpointToHostAction": {
							SchemaProps: spec.SchemaProps{
								Description: "DefaultEndpointToHostAction allows users to configure the default behaviour for traffic between pod to host after calico rules have been processed. Default: ACCEPT (other options: DROP, RETURN)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logSeveritySys": {
							SchemaProps: spec.SchemaProps{
								Description: "LogSeveritySys the severity to set for logs which are sent to syslog Default: INFO (other options: DEBUG, WARNING, ERROR, CRITICAL, NONE)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"prometheusGoMetricsEnabled": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusGoMetricsEnabled enables Prometheus Go runtime metrics collection",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"prometheusMetricsEnabled": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusMetricsEnabled can be set to enable the experimental Prometheus metrics server (default: false)",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"prometheusMetricsPort": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusMetricsPort is the TCP port that the experimental Prometheus metrics server should bind to (default: 9091)",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"prometheusProcessMetricsEnabled": {
							SchemaProps: spec.SchemaProps{
								Description: "PrometheusProcessMetricsEnabled enables Prometheus process metrics collection",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.CiliumNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"version": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"accessLog": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"agentLabels": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"allowLocalhost": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"autoIpv6NodeRoutes": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"bpfRoot": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"containerRuntime": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"containerRuntimeEndpoint": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"debug": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"debugVerbose": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"device": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"disableConntrack": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"disableIpv4": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"disableK8sServices": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"enablePolicy": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"enableTracing": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"envoyLog": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv4ClusterCidrMaskSize": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"ipv4Node": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv4Range": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv4ServiceRange": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv6ClusterAllocCidr": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv6Node": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv6Range": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"ipv6ServiceRange": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"k8sApiServer": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"k8sKubeconfigPath": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"keepBpfTemplates": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"keepConfig": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"labelPrefixFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"labels": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"lb": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"libDir": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logDriver": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"logOpt": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"logstash": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"logstashAgent": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"logstashProbeTimer": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int64",
							},
						},
						"disableMasquerade": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"nat46Range": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"pprof": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"prefilterDevice": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"prometheusServeAddr": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"restore": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"singleClusterRoute": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"socketPath": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"stateDir": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tracePayloadlen": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"tunnel": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ClassicNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ClassicNetworkingSpec is the specification of classic networking mode, integrated into kubernetes",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.CloudConfiguration": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "CloudConfiguration defines the cloud provider configuration",
					Properties: map[string]spec.Schema{
						"multizone": {
							SchemaProps: spec.SchemaProps{
								Description: "GCE cloud-config options",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"nodeTags": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"nodeInstancePrefix": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"disableSecurityGroupIngress": {
							SchemaProps: spec.SchemaProps{
								Description: "AWS cloud-config options",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"elbSecurityGroup": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereUsername": {
							SchemaProps: spec.SchemaProps{
								Description: "vSphere cloud-config specs",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"vSpherePassword": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereServer": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereDatacenter": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereResourcePool": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereDatastore": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"vSphereCoreDNSServer": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.CloudControllerManagerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "CloudControllerManagerConfig is the configuration of the cloud controller",
					Properties: map[string]spec.Schema{
						"master": {
							SchemaProps: spec.SchemaProps{
								Description: "Master is the url for the kube api master.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the verbosity of the logs.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the OCI image of the cloud controller manager.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "CloudProvider is the provider for cloud services.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterName": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterName is the instance prefix for the cluster.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterCIDR is CIDR Range for Pods in cluster.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"allocateNodeCIDRs": {
							SchemaProps: spec.SchemaProps{
								Description: "AllocateNodeCIDRs enables CIDRs for Pods to be allocated and, if ConfigureCloudRoutes is true, to be set on the cloud provider.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"configureCloudRoutes": {
							SchemaProps: spec.SchemaProps{
								Description: "ConfigureCloudRoutes enables CIDRs allocated with to be configured on the cloud provider.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"cidrAllocatorType": {
							SchemaProps: spec.SchemaProps{
								Description: "CIDRAllocatorType specifies the type of CIDR allocator to use.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"leaderElection": {
							SchemaProps: spec.SchemaProps{
								Description: "LeaderElection defines the configuration of leader election client.",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration"),
							},
						},
						"useServiceAccountCredentials": {
							SchemaProps: spec.SchemaProps{
								Description: "UseServiceAccountCredentials controls whether we use individual service account credentials for each controller.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.Cluster": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "Cluster is a specific cluster wrapper",
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
							},
						},
						"spec": {
							SchemaProps: spec.SchemaProps{
								Description: "Spec defines the behavior of a Cluster.",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterList": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ClusterList is a list of clusters",
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
							},
						},
						"items": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.Cluster"),
										},
									},
								},
							},
						},
					},
					Required: []string{"items"},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/kops/pkg/apis/kops/v1alpha1.Cluster"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ClusterSpec defines the configuration for a cluster",
					Properties: map[string]spec.Schema{
						"channel": {
							SchemaProps: spec.SchemaProps{
								Description: "Channel we are following",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"addons": {
							SchemaProps: spec.SchemaProps{
								Description: "Additional addons that should be installed on the cluster",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AddonSpec"),
										},
									},
								},
							},
						},
						"configBase": {
							SchemaProps: spec.SchemaProps{
								Description: "ConfigBase is the path where we store configuration for the cluster This might be different that the location when the cluster spec itself is stored, both because this must be accessible to the cluster, and because it might be on a different cloud or storage system (etcd vs S3)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "The CloudProvider to use (aws or gce)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubernetesVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "The version of kubernetes to install (optional, and can be a \"spec\" like stable)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"zones": {
							SchemaProps: spec.SchemaProps{
								Description: "Configuration of zones we are targeting",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterZoneSpec"),
										},
									},
								},
							},
						},
						"project": {
							SchemaProps: spec.SchemaProps{
								Description: "Project is the cloud project we should use, required on GCE",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"masterPublicName": {
							SchemaProps: spec.SchemaProps{
								Description: "MasterPublicName is the external DNS name for the master nodes",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"masterInternalName": {
							SchemaProps: spec.SchemaProps{
								Description: "MasterInternalName is the internal DNS name for the master nodes",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"networkCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "NetworkCIDR is the CIDR used for the AWS VPC Network, or otherwise allocated to k8s This is a real CIDR, not the internal k8s network On AWS, it maps to the VPC CIDR.  It is not required on GCE.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"additionalNetworkCIDRs": {
							SchemaProps: spec.SchemaProps{
								Description: "AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network On AWS, it maps to any additional CIDRs added to a VPC.",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"networkID": {
							SchemaProps: spec.SchemaProps{
								Description: "NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"topology": {
							SchemaProps: spec.SchemaProps{
								Description: "Topology defines the type of network topology to use on the cluster - default public This is heavily weighted towards AWS for the time being, but should also be agnostic enough to port out to GCE later if needed",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.TopologySpec"),
							},
						},
						"secretStore": {
							SchemaProps: spec.SchemaProps{
								Description: "SecretStore is the VFS path to where secrets are stored",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"keyStore": {
							SchemaProps: spec.SchemaProps{
								Description: "KeyStore is the VFS path to where SSL keys and certificates are stored",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"configStore": {
							SchemaProps: spec.SchemaProps{
								Description: "ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroupss etc) is stored",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"dnsZone": {
							SchemaProps: spec.SchemaProps{
								Description: "DNSZone is the DNS zone we should use when configuring DNS This is because some clouds let us define a managed zone foo.bar, and then have kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone. DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName Note that DNSZone can either by the host name of the zone (containing dots), or can be an identifier for the zone.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"additionalSans": {
							SchemaProps: spec.SchemaProps{
								Description: "AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"clusterDNSDomain": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"multizone": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterName is a unique identifier for the cluster, and currently must be a DNS name ClusterName       string `json:\",omitempty\"`",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"serviceClusterIPRange": {
							SchemaProps: spec.SchemaProps{
								Description: "ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"nonMasqueradeCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods & services live) It cannot overlap ServiceClusterIPRange",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"adminAccess": {
							SchemaProps: spec.SchemaProps{
								Description: "AdminAccess determines the permitted access to the admin endpoints (SSH & master HTTPS) Currently only a single CIDR is supported (though a richer grammar could be added in future)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"isolateMasters": {
							SchemaProps: spec.SchemaProps{
								Description: "IsolatesMasters determines whether we should lock down masters so that they are not on the pod network. true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master if they have hostNetwork=true. false is now the default, and it will:\n * give the master a normal PodCIDR\n * run kube-proxy on the master\n * enable debugging handlers on the master, so kubectl logs works",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"updatePolicy": {
							SchemaProps: spec.SchemaProps{
								Description: "UpdatePolicy determines the policy for applying upgrades automatically. Valid values:\n  'external' do not apply updates automatically - they are applied manually or by an external system\n  missing: default policy (currently OS security upgrades that do not require a reboot)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"additionalPolicies": {
							SchemaProps: spec.SchemaProps{
								Description: "Additional policies to add for roles",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"fileAssets": {
							SchemaProps: spec.SchemaProps{
								Description: "A collection of files assets for deployed cluster wide",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.FileAssetSpec"),
										},
									},
								},
							},
						},
						"egressProxy": {
							SchemaProps: spec.SchemaProps{
								Description: "HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.EgressProxySpec"),
							},
						},
						"sshKeyName": {
							SchemaProps: spec.SchemaProps{
								Description: "SSHKeyName specifies a preexisting SSH key to use",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdClusters": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdClusters stores the configuration for each cluster",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdClusterSpec"),
										},
									},
								},
							},
						},
						"docker": {
							SchemaProps: spec.SchemaProps{
								Description: "Component configurations",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.DockerConfig"),
							},
						},
						"kubeDNS": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeDNSConfig"),
							},
						},
						"kubeAPIServer": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeAPIServerConfig"),
							},
						},
						"kubeControllerManager": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeControllerManagerConfig"),
							},
						},
						"cloudControllerManager": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.CloudControllerManagerConfig"),
							},
						},
						"kubeScheduler": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeSchedulerConfig"),
							},
						},
						"kubeProxy": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeProxyConfig"),
							},
						},
						"kubelet": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeletConfigSpec"),
							},
						},
						"masterKubelet": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeletConfigSpec"),
							},
						},
						"cloudConfig": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.CloudConfiguration"),
							},
						},
						"externalDns": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.ExternalDNSConfig"),
							},
						},
						"networking": {
							SchemaProps: spec.SchemaProps{
								Description: "Networking configuration",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.NetworkingSpec"),
							},
						},
						"api": {
							SchemaProps: spec.SchemaProps{
								Description: "API field controls how the API is exposed outside the cluster",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AccessSpec"),
							},
						},
						"authentication": {
							SchemaProps: spec.SchemaProps{
								Description: "Authentication field controls how the cluster is configured for authentication",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AuthenticationSpec"),
							},
						},
						"authorization": {
							SchemaProps: spec.SchemaProps{
								Description: "Authorization field controls how the cluster is configured for authorization",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AuthorizationSpec"),
							},
						},
						"nodeAuthorization": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeAuthorization defined the custom node authorization configuration",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.NodeAuthorizationSpec"),
							},
						},
						"cloudLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "Tags for AWS instance groups",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"hooks": {
							SchemaProps: spec.SchemaProps{
								Description: "Hooks for custom actions e.g. on first installation",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.HookSpec"),
										},
									},
								},
							},
						},
						"assets": {
							SchemaProps: spec.SchemaProps{
								Description: "Alternative locations for files and containers",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.Assets"),
							},
						},
						"iam": {
							SchemaProps: spec.SchemaProps{
								Description: "IAM field adds control over the IAM security policies applied to resources",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.IAMSpec"),
							},
						},
						"encryptionConfig": {
							SchemaProps: spec.SchemaProps{
								Description: "EncryptionConfig holds the encryption config",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"target": {
							SchemaProps: spec.SchemaProps{
								Description: "Target allows for us to nest extra config for targets such as terraform",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.TargetSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.AccessSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.AddonSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.Assets", "k8s.io/kops/pkg/apis/kops/v1alpha1.AuthenticationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.AuthorizationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.CloudConfiguration", "k8s.io/kops/pkg/apis/kops/v1alpha1.CloudControllerManagerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterZoneSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.DockerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.EgressProxySpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdClusterSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.ExternalDNSConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.FileAssetSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.HookSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.IAMSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeAPIServerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeControllerManagerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeDNSConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeProxyConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeSchedulerConfig", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeletConfigSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.NetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.NodeAuthorizationSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.TargetSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.TopologySpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ClusterZoneSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"privateCIDR": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"cidr": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"id": {
							SchemaProps: spec.SchemaProps{
								Description: "ProviderID is the cloud provider id for the objects associated with the zone (the subnet on AWS)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"egress": {
							SchemaProps: spec.SchemaProps{
								Description: "Egress defines the method of traffic egress for this subnet",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.DNSAccessSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.DNSSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"type": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.DockerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "DockerConfig is the configuration for docker",
					Properties: map[string]spec.Schema{
						"authorizationPlugins": {
							SchemaProps: spec.SchemaProps{
								Description: "AuthorizationPlugins is a list of authorization plugins",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"bridge": {
							SchemaProps: spec.SchemaProps{
								Description: "Bridge is the network interface containers should bind onto",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"bridgeIP": {
							SchemaProps: spec.SchemaProps{
								Description: "BridgeIP is a specific IP address and netmask for the docker0 bridge, using standard CIDR notation",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"dataRoot": {
							SchemaProps: spec.SchemaProps{
								Description: "DataRoot is the root directory of persistent docker state (default \"/var/lib/docker\")",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"defaultUlimit": {
							SchemaProps: spec.SchemaProps{
								Description: "DefaultUlimit is the ulimits for containers",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"execRoot": {
							SchemaProps: spec.SchemaProps{
								Description: "ExecRoot is the root directory for execution state files (default \"/var/run/docker\")",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"hosts": {
							SchemaProps: spec.SchemaProps{
								Description: "Hosts enables you to configure the endpoints the docker daemon listens on i.e tcp://0.0.0.0.2375 or unix:///var/run/docker.sock etc",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"ipMasq": {
							SchemaProps: spec.SchemaProps{
								Description: "IPMasq enables ip masquerading for containers",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"ipTables": {
							SchemaProps: spec.SchemaProps{
								Description: "IPtables enables addition of iptables rules",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"insecureRegistry": {
							SchemaProps: spec.SchemaProps{
								Description: "InsecureRegistry enable insecure registry communication @question according to dockers this a list??",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"liveRestore": {
							SchemaProps: spec.SchemaProps{
								Description: "LiveRestore enables live restore of docker when containers are still running",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"logDriver": {
							SchemaProps: spec.SchemaProps{
								Description: "LogDriver is the default driver for container logs (default \"json-file\")",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the logging level (\"debug\", \"info\", \"warn\", \"error\", \"fatal\") (default \"info\")",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logOpt": {
							SchemaProps: spec.SchemaProps{
								Description: "Logopt is a series of options given to the log driver options for containers",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"mtu": {
							SchemaProps: spec.SchemaProps{
								Description: "MTU is the containers network MTU",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"registryMirrors": {
							SchemaProps: spec.SchemaProps{
								Description: "RegistryMirrors is a referred list of docker registry mirror",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"storage": {
							SchemaProps: spec.SchemaProps{
								Description: "Storage is the docker storage driver to use",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"storageOpts": {
							SchemaProps: spec.SchemaProps{
								Description: "StorageOpts is a series of options passed to the storage driver",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"userNamespaceRemap": {
							SchemaProps: spec.SchemaProps{
								Description: "UserNamespaceRemap sets the user namespace remapping option for the docker daemon",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"version": {
							SchemaProps: spec.SchemaProps{
								Description: "Version is consumed by the nodeup and used to pick the docker version",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.EgressProxySpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"httpProxy": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.HTTPProxy"),
							},
						},
						"excludes": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.HTTPProxy"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdBackupSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "EtcdBackupSpec describes how we want to do backups of etcd",
					Properties: map[string]spec.Schema{
						"backupStore": {
							SchemaProps: spec.SchemaProps{
								Description: "BackupStore is the VFS path where we will read/write backup data",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the etcd backup manager image to use.  Setting this will create a sidecar container in the etcd pod with the specified image.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdClusterSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "EtcdClusterSpec is the etcd cluster specification",
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is the name of the etcd cluster (main, events etc)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdMembers": {
							SchemaProps: spec.SchemaProps{
								Description: "Members stores the configurations for each member of the cluster (including the data volume)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdMemberSpec"),
										},
									},
								},
							},
						},
						"enableTLSAuth": {
							SchemaProps: spec.SchemaProps{
								Description: "EnableTLSAuth indicates client and peer TLS auth should be enforced",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"enableEtcdTLS": {
							SchemaProps: spec.SchemaProps{
								Description: "EnableEtcdTLS indicates the etcd service should use TLS between peers and clients",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"version": {
							SchemaProps: spec.SchemaProps{
								Description: "Version is the version of etcd to run i.e. 2.1.2, 3.0.17 etcd",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"leaderElectionTimeout": {
							SchemaProps: spec.SchemaProps{
								Description: "LeaderElectionTimeout is the time (in milliseconds) for an etcd leader election timeout",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"heartbeatInterval": {
							SchemaProps: spec.SchemaProps{
								Description: "HeartbeatInterval is the time (in milliseconds) for an etcd heartbeat interval",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the etcd docker image to use. Setting this will ignore the Version specified.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"backups": {
							SchemaProps: spec.SchemaProps{
								Description: "Backups describes how we do backups of etcd",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdBackupSpec"),
							},
						},
						"manager": {
							SchemaProps: spec.SchemaProps{
								Description: "Manager describes the manager configuration",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdManagerSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdBackupSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdManagerSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdMemberSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdManagerSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "EtcdManagerSpec describes how we configure the etcd manager",
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the etcd manager image to use.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.EtcdMemberSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "EtcdMemberSpec is a specification for a etcd member",
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is the name of the member within the etcd cluster",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"zone": {
							SchemaProps: spec.SchemaProps{
								Description: "Zone is the zone the member lives",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"volumeType": {
							SchemaProps: spec.SchemaProps{
								Description: "VolumeType is the underlining cloud storage class",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"volumeIops": {
							SchemaProps: spec.SchemaProps{
								Description: "If volume type is io1, then we need to specify the number of Iops.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"volumeSize": {
							SchemaProps: spec.SchemaProps{
								Description: "VolumeSize is the underlining cloud volume size",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"kmsKeyId": {
							SchemaProps: spec.SchemaProps{
								Description: "KmsKeyId is a AWS KMS ID used to encrypt the volume",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"encryptedVolume": {
							SchemaProps: spec.SchemaProps{
								Description: "EncryptedVolume indicates you want to encrypt the volume",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ExecContainerAction": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ExecContainerAction defines an hood action",
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the docker image",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"command": {
							SchemaProps: spec.SchemaProps{
								Description: "Command is the command supplied to the above image",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"environment": {
							SchemaProps: spec.SchemaProps{
								Description: "Environment is a map of environment variables added to the hook",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ExternalDNSConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ExternalDNSConfig are options of the dns-controller",
					Properties: map[string]spec.Schema{
						"disable": {
							SchemaProps: spec.SchemaProps{
								Description: "Disable indicates we do not wish to run the dns-controller addon",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"watchIngress": {
							SchemaProps: spec.SchemaProps{
								Description: "WatchIngress indicates you want the dns-controller to watch and create dns entries for ingress resources",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"watchNamespace": {
							SchemaProps: spec.SchemaProps{
								Description: "WatchNamespace is namespace to watch, defaults to all (use to control whom can creates dns entries)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.ExternalNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "ExternalNetworkingSpec is the specification for networking that is implemented by a Daemonset It also uses kubenet",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.FileAssetSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "FileAssetSpec defines the structure for a file asset",
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is a shortened reference to the asset",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"path": {
							SchemaProps: spec.SchemaProps{
								Description: "Path is the location this file should reside",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"roles": {
							SchemaProps: spec.SchemaProps{
								Description: "Roles is a list of roles the file asset should be applied, defaults to all",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"content": {
							SchemaProps: spec.SchemaProps{
								Description: "Content is the contents of the file",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"isBase64": {
							SchemaProps: spec.SchemaProps{
								Description: "IsBase64 indicates the contents is base64 encoded",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.FlannelNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "FlannelNetworkingSpec declares that we want Flannel networking",
					Properties: map[string]spec.Schema{
						"backend": {
							SchemaProps: spec.SchemaProps{
								Description: "Backend is the backend overlay type we want to use (vxlan or udp)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.HTTPProxy": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"host": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"port": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.HookSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "HookSpec is a definition hook",
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is an optional name for the hook, otherwise the name is kops-hook-<index>",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"disabled": {
							SchemaProps: spec.SchemaProps{
								Description: "Disabled indicates if you want the unit switched off",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"roles": {
							SchemaProps: spec.SchemaProps{
								Description: "Roles is an optional list of roles the hook should be rolled out to, defaults to all",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"requires": {
							SchemaProps: spec.SchemaProps{
								Description: "Requires is a series of systemd units the action requires",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"before": {
							SchemaProps: spec.SchemaProps{
								Description: "Before is a series of systemd units which this hook must run before",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"execContainer": {
							SchemaProps: spec.SchemaProps{
								Description: "ExecContainer is the image itself",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.ExecContainerAction"),
							},
						},
						"manifest": {
							SchemaProps: spec.SchemaProps{
								Description: "Manifest is a raw systemd unit file",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"useRawManifest": {
							SchemaProps: spec.SchemaProps{
								Description: "UseRawManifest indicates that the contents of Manifest should be used as the contents of the systemd unit, unmodified. Before and Requires are ignored when used together with this value (and validation shouldn't allow them to be set)",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.ExecContainerAction"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.IAMProfileSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "IAMProfileSpec is the AWS IAM Profile to attach to instances in this instance group. Specify the ARN for the IAM instance profile (AWS only).",
					Properties: map[string]spec.Schema{
						"profile": {
							SchemaProps: spec.SchemaProps{
								Description: "Profile of the cloud group iam profile. In aws this is the arn for the iam instance profile",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.IAMSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "IAMSpec adds control over the IAM security policies applied to resources",
					Properties: map[string]spec.Schema{
						"legacy": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"allowContainerRegistry": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
					},
					Required: []string{"legacy"},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroup": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "InstanceGroup represents a group of instances (either nodes or masters) with the same configuration",
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
							},
						},
						"spec": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroupSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroupSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroupList": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
							},
						},
						"items": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroup"),
										},
									},
								},
							},
						},
					},
					Required: []string{"items"},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroup"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.InstanceGroupSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "InstanceGroupSpec is the specification for a instanceGroup",
					Properties: map[string]spec.Schema{
						"role": {
							SchemaProps: spec.SchemaProps{
								Description: "Type determines the role of instances in this group: masters or nodes",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the instance instance (ami etc) we should use",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"minSize": {
							SchemaProps: spec.SchemaProps{
								Description: "MinSize is the minimum size of the pool",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"maxSize": {
							SchemaProps: spec.SchemaProps{
								Description: "MaxSize is the maximum size of the pool",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"machineType": {
							SchemaProps: spec.SchemaProps{
								Description: "MachineType is the instance class",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"rootVolumeSize": {
							SchemaProps: spec.SchemaProps{
								Description: "RootVolumeSize is the size of the EBS root volume to use, in GB",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"rootVolumeType": {
							SchemaProps: spec.SchemaProps{
								Description: "RootVolumeType is the type of the EBS root volume to use (e.g. gp2)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"rootVolumeIops": {
							SchemaProps: spec.SchemaProps{
								Description: "If volume type is io1, then we need to specify the number of Iops.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"rootVolumeOptimization": {
							SchemaProps: spec.SchemaProps{
								Description: "RootVolumeOptimization enables EBS optimization for an instance",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"hooks": {
							SchemaProps: spec.SchemaProps{
								Description: "Hooks is a list of hooks for this instanceGroup, note: these can override the cluster wide ones if required",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.HookSpec"),
										},
									},
								},
							},
						},
						"maxPrice": {
							SchemaProps: spec.SchemaProps{
								Description: "MaxPrice indicates this is a spot-pricing group, with the specified value as our max-price bid",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"associatePublicIp": {
							SchemaProps: spec.SchemaProps{
								Description: "AssociatePublicIP is true if we want instances to have a public IP",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"additionalSecurityGroups": {
							SchemaProps: spec.SchemaProps{
								Description: "AdditionalSecurityGroups attaches additional security groups (e.g. i-123456)",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"cloudLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "CloudLabels indicates the labels for instances in this group, at the AWS level",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"nodeLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeLabels indicates the kubernetes labels for nodes in this group",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"fileAssets": {
							SchemaProps: spec.SchemaProps{
								Description: "A collection of files assets for deployed cluster wide",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.FileAssetSpec"),
										},
									},
								},
							},
						},
						"tenancy": {
							SchemaProps: spec.SchemaProps{
								Description: "Describes the tenancy of the instance group. Can be either default or dedicated. Currently only applies to AWS.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubelet": {
							SchemaProps: spec.SchemaProps{
								Description: "Kubelet overrides kubelet config from the ClusterSpec",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubeletConfigSpec"),
							},
						},
						"taints": {
							SchemaProps: spec.SchemaProps{
								Description: "Taints indicates the kubernetes taints for nodes in this group",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"additionalUserData": {
							SchemaProps: spec.SchemaProps{
								Description: "AdditionalUserData is any additional user-data to be passed to the host",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.UserData"),
										},
									},
								},
							},
						},
						"zones": {
							SchemaProps: spec.SchemaProps{
								Description: "Zones is the names of the Zones where machines in this instance group should be placed This is needed for regional subnets (e.g. GCE), to restrict placement to particular zones",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"suspendProcesses": {
							SchemaProps: spec.SchemaProps{
								Description: "SuspendProcesses disables the listed Scaling Policies",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"externalLoadBalancers": {
							SchemaProps: spec.SchemaProps{
								Description: "ExternalLoadBalancers define loadbalancers that should be attached to the instancegroup",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.LoadBalancer"),
										},
									},
								},
							},
						},
						"detailedInstanceMonitoring": {
							SchemaProps: spec.SchemaProps{
								Description: "DetailedInstanceMonitoring defines if detailed-monitoring is enabled (AWS only)",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"iam": {
							SchemaProps: spec.SchemaProps{
								Description: "IAMProfileSpec defines the identity of the cloud group iam profile (AWS only).",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.IAMProfileSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.FileAssetSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.HookSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.IAMProfileSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubeletConfigSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.LoadBalancer", "k8s.io/kops/pkg/apis/kops/v1alpha1.UserData"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KopeioAuthenticationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KopeioNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KopeioNetworkingSpec declares that we want Kopeio networking",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubeAPIServerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubeAPIServerConfig defines the configuration for the kube api",
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the docker container used",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the logging level of the api",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "CloudProvider is the name of the cloudProvider we are using, aws, gce etcd",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"securePort": {
							SchemaProps: spec.SchemaProps{
								Description: "SecurePort is the port the kube runs on",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"insecurePort": {
							SchemaProps: spec.SchemaProps{
								Description: "InsecurePort is the port the insecure api runs",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"address": {
							SchemaProps: spec.SchemaProps{
								Description: "Address is the binding address for the kube api: Deprecated - use insecure-bind-address and bind-address",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"bindAddress": {
							SchemaProps: spec.SchemaProps{
								Description: "BindAddress is the binding address for the secure kubernetes API",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"insecureBindAddress": {
							SchemaProps: spec.SchemaProps{
								Description: "InsecureBindAddress is the binding address for the InsecurePort for the insecure kubernetes API",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"enableBootstrapTokenAuth": {
							SchemaProps: spec.SchemaProps{
								Description: "EnableBootstrapAuthToken enables 'bootstrap.kubernetes.io/token' in the 'kube-system' namespace to be used for TLS bootstrapping authentication",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"enableAggregatorRouting": {
							SchemaProps: spec.SchemaProps{
								Description: "EnableAggregatorRouting enables aggregator routing requests to endpoints IP rather than cluster IP",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"admissionControl": {
							SchemaProps: spec.SchemaProps{
								Description: "Deprecated: AdmissionControl is a list of admission controllers to use",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"enableAdmissionPlugins": {
							SchemaProps: spec.SchemaProps{
								Description: "EnableAdmissionPlugins is a list of enabled admission plugins",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"disableAdmissionPlugins": {
							SchemaProps: spec.SchemaProps{
								Description: "DisableAdmissionPlugins is a list of disabled admission plugins",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"serviceClusterIPRange": {
							SchemaProps: spec.SchemaProps{
								Description: "ServiceClusterIPRange is the service address range",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"serviceNodePortRange": {
							SchemaProps: spec.SchemaProps{
								Description: "Passed as --service-node-port-range to kube-apiserver. Expects 'startPort-endPort' format. Eg. 30000-33000",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdServers": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdServers is a list of the etcd service to connect",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"etcdServersOverrides": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdServersOverrides is per-resource etcd servers overrides, comma separated. The individual override format: group/resource#servers, where servers are http://ip:port, semicolon separated",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"etcdCaFile": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdCAFile is the path to a ca certificate",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdCertFile": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdCertFile is the path to a certificate",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdKeyFile": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdKeyFile is the path to a private key",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"basicAuthFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"clientCAFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tlsCertFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tlsPrivateKeyFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tokenAuthFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"allowPrivileged": {
							SchemaProps: spec.SchemaProps{
								Description: "AllowPrivileged indicates if we can run privileged containers",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"apiServerCount": {
							SchemaProps: spec.SchemaProps{
								Description: "APIServerCount is the number of api servers",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"runtimeConfig": {
							SchemaProps: spec.SchemaProps{
								Description: "RuntimeConfig is a series of keys/values are parsed into the `--runtime-config` parameters",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"kubeletClientCertificate": {
							SchemaProps: spec.SchemaProps{
								Description: "KubeletClientCertificate is the path of a certificate for secure communication between api and kubelet",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubeletClientKey": {
							SchemaProps: spec.SchemaProps{
								Description: "KubeletClientKey is the path of a private to secure communication between api and kubelet",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"anonymousAuth": {
							SchemaProps: spec.SchemaProps{
								Description: "AnonymousAuth indicates if anonymous authentication is permitted",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"kubeletPreferredAddressTypes": {
							SchemaProps: spec.SchemaProps{
								Description: "KubeletPreferredAddressTypes is a list of the preferred NodeAddressTypes to use for kubelet connections",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"storageBackend": {
							SchemaProps: spec.SchemaProps{
								Description: "StorageBackend is the backend storage",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcUsernameClaim": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCUsernameClaim is the OpenID claim to use as the user name. Note that claims other than the default ('sub') is not guaranteed to be unique and immutable.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcUsernamePrefix": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCUsernamePrefix is the prefix prepended to username claims to prevent clashes with existing names (such as 'system:' users).",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcGroupsClaim": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCGroupsClaim if provided, the name of a custom OpenID Connect claim for specifying user groups. The claim value is expected to be a string or array of strings.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcGroupsPrefix": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCGroupsPrefix is the prefix prepended to group claims to prevent clashes with existing names (such as 'system:' groups)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcIssuerURL": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCIssuerURL is the URL of the OpenID issuer, only HTTPS scheme will be accepted. If set, it will be used to verify the OIDC JSON Web Token (JWT).",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcClientID": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCClientID is the client ID for the OpenID Connect client, must be set if oidc-issuer-url is set.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"oidcCAFile": {
							SchemaProps: spec.SchemaProps{
								Description: "OIDCCAFile if set, the OpenID server's certificate will be verified by one of the authorities in the oidc-ca-file",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"proxyClientCertFile": {
							SchemaProps: spec.SchemaProps{
								Description: "The apiserver's client certificate used for outbound requests.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"proxyClientKeyFile": {
							SchemaProps: spec.SchemaProps{
								Description: "The apiserver's client key used for outbound requests.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"auditLogFormat": {
							SchemaProps: spec.SchemaProps{
								Description: "AuditLogFormat flag specifies the format type for audit log files.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"auditLogPath": {
							SchemaProps: spec.SchemaProps{
								Description: "If set, all requests coming to the apiserver will be logged to this file.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"auditLogMaxAge": {
							SchemaProps: spec.SchemaProps{
								Description: "The maximum number of days to retain old audit log files based on the timestamp encoded in their filename.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"auditLogMaxBackups": {
							SchemaProps: spec.SchemaProps{
								Description: "The maximum number of old audit log files to retain.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"auditLogMaxSize": {
							SchemaProps: spec.SchemaProps{
								Description: "The maximum size in megabytes of the audit log file before it gets rotated. Defaults to 100MB.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"auditPolicyFile": {
							SchemaProps: spec.SchemaProps{
								Description: "AuditPolicyFile is the full path to a advanced audit configuration file a.g. /srv/kubernetes/audit.conf",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"authenticationTokenWebhookConfigFile": {
							SchemaProps: spec.SchemaProps{
								Description: "File with webhook configuration for token authentication in kubeconfig format. The API server will query the remote service to determine authentication for bearer tokens.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"authenticationTokenWebhookCacheTtl": {
							SchemaProps: spec.SchemaProps{
								Description: "The duration to cache responses from the webhook token authenticator. Default is 2m. (default 2m0s)",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"authorizationMode": {
							SchemaProps: spec.SchemaProps{
								Description: "AuthorizationMode is the authorization mode the kubeapi is running in",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"authorizationRbacSuperUser": {
							SchemaProps: spec.SchemaProps{
								Description: "AuthorizationRBACSuperUser is the name of the superuser for default rbac",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"experimentalEncryptionProviderConfig": {
							SchemaProps: spec.SchemaProps{
								Description: "ExperimentalEncryptionProviderConfig enables encryption at rest for secrets.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"requestheaderUsernameHeaders": {
							SchemaProps: spec.SchemaProps{
								Description: "List of request headers to inspect for usernames. X-Remote-User is common.",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"requestheaderGroupHeaders": {
							SchemaProps: spec.SchemaProps{
								Description: "List of request headers to inspect for groups. X-Remote-Group is suggested.",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"requestheaderExtraHeaderPrefixes": {
							SchemaProps: spec.SchemaProps{
								Description: "List of request header prefixes to inspect. X-Remote-Extra- is suggested.",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"requestheaderClientCAFile": {
							SchemaProps: spec.SchemaProps{
								Description: "Root certificate bundle to use to verify client certificates on incoming requests before trusting usernames in headers specified by --requestheader-username-headers",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"requestheaderAllowedNames": {
							SchemaProps: spec.SchemaProps{
								Description: "List of client certificate common names to allow to provide usernames in headers specified by --requestheader-username-headers. If empty, any client certificate validated by the authorities in --requestheader-client-ca-file is allowed.",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"featureGates": {
							SchemaProps: spec.SchemaProps{
								Description: "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"maxRequestsInflight": {
							SchemaProps: spec.SchemaProps{
								Description: "MaxRequestsInflight The maximum number of non-mutating requests in flight at a given time.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"etcdQuorumRead": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdQuorumRead configures the etcd-quorum-read flag, which forces consistent reads from etcd",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"minRequestTimeout": {
							SchemaProps: spec.SchemaProps{
								Description: "MinRequestTimeout configures the minimum number of seconds a handler must keep a request open before timing it out. Currently only honored by the watch request handler",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubeControllerManagerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubeControllerManagerConfig is the configuration for the controller",
					Properties: map[string]spec.Schema{
						"master": {
							SchemaProps: spec.SchemaProps{
								Description: "Master is the url for the kube api master",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the defined logLevel",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"serviceAccountPrivateKeyFile": {
							SchemaProps: spec.SchemaProps{
								Description: "ServiceAccountPrivateKeyFile the location for a certificate for service account signing",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the docker image to use",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "CloudProvider is the provider for cloud services.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterName": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterName is the instance prefix for the cluster.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterCIDR is CIDR Range for Pods in cluster.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"allocateNodeCIDRs": {
							SchemaProps: spec.SchemaProps{
								Description: "AllocateNodeCIDRs enables CIDRs for Pods to be allocated and, if ConfigureCloudRoutes is true, to be set on the cloud provider.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"nodeCIDRMaskSize": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeCIDRMaskSize set the size for the mask of the nodes.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"configureCloudRoutes": {
							SchemaProps: spec.SchemaProps{
								Description: "ConfigureCloudRoutes enables CIDRs allocated with to be configured on the cloud provider.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"cidrAllocatorType": {
							SchemaProps: spec.SchemaProps{
								Description: "CIDRAllocatorType specifies the type of CIDR allocator to use.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"rootCAFile": {
							SchemaProps: spec.SchemaProps{
								Description: "rootCAFile is the root certificate authority will be included in service account's token secret. This must be a valid PEM-encoded CA bundle.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"leaderElection": {
							SchemaProps: spec.SchemaProps{
								Description: "LeaderElection defines the configuration of leader election client.",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration"),
							},
						},
						"attachDetachReconcileSyncPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "ReconcilerSyncLoopPeriod is the amount of time the reconciler sync states loop wait between successive executions. Is set to 1 min by kops by default",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"terminatedPodGCThreshold": {
							SchemaProps: spec.SchemaProps{
								Description: "TerminatedPodGCThreshold is the number of terminated pods that can exist before the terminated pod garbage collector starts deleting terminated pods. If <= 0, the terminated pod garbage collector is disabled.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"nodeMonitorPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeMonitorPeriod is the period for syncing NodeStatus in NodeController. (default 5s)",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"nodeMonitorGracePeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeMonitorGracePeriod is the amount of time which we allow running Node to be unresponsive before marking it unhealthy. (default 40s) Must be N-1 times more than kubelet's nodeStatusUpdateFrequency, where N means number of retries allowed for kubelet to post node status.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"podEvictionTimeout": {
							SchemaProps: spec.SchemaProps{
								Description: "PodEvictionTimeout is the grace period for deleting pods on failed nodes. (default 5m0s)",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"useServiceAccountCredentials": {
							SchemaProps: spec.SchemaProps{
								Description: "UseServiceAccountCredentials controls whether we use individual service account credentials for each controller.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"horizontalPodAutoscalerSyncPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "HorizontalPodAutoscalerSyncPeriod is the amount of time between syncs During each period, the controller manager queries the resource utilization against the metrics specified in each HorizontalPodAutoscaler definition.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"horizontalPodAutoscalerDownscaleDelay": {
							SchemaProps: spec.SchemaProps{
								Description: "HorizontalPodAutoscalerDownscaleDelay is a duration that specifies how long the autoscaler has to wait before another downscale operation can be performed after the current one has completed.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"horizontalPodAutoscalerUpscaleDelay": {
							SchemaProps: spec.SchemaProps{
								Description: "HorizontalPodAutoscalerUpscaleDelay is a duration that specifies how long the autoscaler has to wait before another upscale operation can be performed after the current one has completed.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"horizontalPodAutoscalerUseRestClients": {
							SchemaProps: spec.SchemaProps{
								Description: "HorizontalPodAutoscalerUseRestClients determines if the new-style clients should be used if support for custom metrics is enabled.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"featureGates": {
							SchemaProps: spec.SchemaProps{
								Description: "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration", "k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubeDNSConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubeDNSConfig defines the kube dns configuration",
					Properties: map[string]spec.Schema{
						"cacheMaxSize": {
							SchemaProps: spec.SchemaProps{
								Description: "CacheMaxSize is the maximum entries to keep in dnsmaq",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"cacheMaxConcurrent": {
							SchemaProps: spec.SchemaProps{
								Description: "CacheMaxConcurrent is the maximum number of concurrent queries for dnsmasq",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"domain": {
							SchemaProps: spec.SchemaProps{
								Description: "Domain is the dns domain",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the name of the docker image to run - @deprecated as this is now in the addon",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"replicas": {
							SchemaProps: spec.SchemaProps{
								Description: "Replicas is the number of pod replicas - @deprecated as this is now in the addon, and controlled by autoscaler",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"provider": {
							SchemaProps: spec.SchemaProps{
								Description: "Provider indicates whether CoreDNS or kube-dns will be the default service discovery.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"serverIP": {
							SchemaProps: spec.SchemaProps{
								Description: "ServerIP is the server ip",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"stubDomains": {
							SchemaProps: spec.SchemaProps{
								Description: "StubDomains redirects a domains to another DNS service",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type: []string{"array"},
											Items: &spec.SchemaOrArray{
												Schema: &spec.Schema{
													SchemaProps: spec.SchemaProps{
														Type:   []string{"string"},
														Format: "",
													},
												},
											},
										},
									},
								},
							},
						},
						"upstreamNameservers": {
							SchemaProps: spec.SchemaProps{
								Description: "UpstreamNameservers sets the upstream nameservers for queries not on the cluster domain",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubeProxyConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubeProxyConfig defines the configuration for a proxy",
					Properties: map[string]spec.Schema{
						"image": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"cpuRequest": {
							SchemaProps: spec.SchemaProps{
								Description: "CPURequest, cpu request compute resource for kube proxy e.g. \"20m\"",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cpuLimit": {
							SchemaProps: spec.SchemaProps{
								Description: "CPULimit, cpu limit compute resource for kube proxy e.g. \"30m\"",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"memoryRequest": {
							SchemaProps: spec.SchemaProps{
								Description: "MemoryRequest, memory request compute resource for kube proxy e.g. \"30Mi\"",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"memoryLimit": {
							SchemaProps: spec.SchemaProps{
								Description: "MemoryLimit, memory limit compute resource for kube proxy e.g. \"30Mi\"",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the logging level of the proxy",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"clusterCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterCIDR is the CIDR range of the pods in the cluster",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"hostnameOverride": {
							SchemaProps: spec.SchemaProps{
								Description: "HostnameOverride, if non-empty, will be used as the identity instead of the actual hostname.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"bindAddress": {
							SchemaProps: spec.SchemaProps{
								Description: "BindAddress is IP address for the proxy server to serve on",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"master": {
							SchemaProps: spec.SchemaProps{
								Description: "Master is the address of the Kubernetes API server (overrides any value in kubeconfig)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"enabled": {
							SchemaProps: spec.SchemaProps{
								Description: "Enabled allows enabling or disabling kube-proxy",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"proxyMode": {
							SchemaProps: spec.SchemaProps{
								Description: "Which proxy mode to use: (userspace, iptables(default), ipvs)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"featureGates": {
							SchemaProps: spec.SchemaProps{
								Description: "FeatureGates is a series of key pairs used to switch on features for the proxy",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"conntrackMaxPerCore": {
							SchemaProps: spec.SchemaProps{
								Description: "Maximum number of NAT connections to track per CPU core (default: 131072)",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"conntrackMin": {
							SchemaProps: spec.SchemaProps{
								Description: "Minimum number of conntrack entries to allocate, regardless of conntrack-max-per-core",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubeSchedulerConfig": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubeSchedulerConfig is the configuration for the kube-scheduler",
					Properties: map[string]spec.Schema{
						"master": {
							SchemaProps: spec.SchemaProps{
								Description: "Master is a url to the kube master",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the logging level",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the docker image to use",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"leaderElection": {
							SchemaProps: spec.SchemaProps{
								Description: "LeaderElection defines the configuration of leader election client.",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration"),
							},
						},
						"usePolicyConfigMap": {
							SchemaProps: spec.SchemaProps{
								Description: "UsePolicyConfigMap enable setting the scheduler policy from a configmap",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"featureGates": {
							SchemaProps: spec.SchemaProps{
								Description: "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubeletConfigSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubeletConfigSpec defines the kubelet configuration",
					Properties: map[string]spec.Schema{
						"apiServers": {
							SchemaProps: spec.SchemaProps{
								Description: "APIServers is not used for clusters version 1.6 and later - flag removed",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"anonymousAuth": {
							SchemaProps: spec.SchemaProps{
								Description: "AnonymousAuth permits you to control auth to the kubelet api",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"authorizationMode": {
							SchemaProps: spec.SchemaProps{
								Description: "AuthorizationMode is the authorization mode the kubelet is running in",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"bootstrapKubeconfig": {
							SchemaProps: spec.SchemaProps{
								Description: "BootstrapKubeconfig is the path to a kubeconfig file that will be used to get client certificate for kube",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clientCaFile": {
							SchemaProps: spec.SchemaProps{
								Description: "ClientCAFile is the path to a CA certificate",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"tlsCertFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"tlsPrivateKeyFile": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"kubeconfigPath": {
							SchemaProps: spec.SchemaProps{
								Description: "KubeconfigPath is the path of kubeconfig for the kubelet",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"requireKubeconfig": {
							SchemaProps: spec.SchemaProps{
								Description: "RequireKubeconfig indicates a kubeconfig is required",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"logLevel": {
							SchemaProps: spec.SchemaProps{
								Description: "LogLevel is the logging level of the kubelet",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"podManifestPath": {
							SchemaProps: spec.SchemaProps{
								Description: "config is the path to the config file or directory of files",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"hostnameOverride": {
							SchemaProps: spec.SchemaProps{
								Description: "HostnameOverride is the hostname used to identify the kubelet instead of the actual hostname.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"podInfraContainerImage": {
							SchemaProps: spec.SchemaProps{
								Description: "PodInfraContainerImage is the image whose network/ipc containers in each pod will use.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"seccompProfileRoot": {
							SchemaProps: spec.SchemaProps{
								Description: "SeccompProfileRoot is the directory path for seccomp profiles.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"allowPrivileged": {
							SchemaProps: spec.SchemaProps{
								Description: "AllowPrivileged enables containers to request privileged mode (defaults to false)",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"enableDebuggingHandlers": {
							SchemaProps: spec.SchemaProps{
								Description: "EnableDebuggingHandlers enables server endpoints for log collection and local running of containers and commands",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"registerNode": {
							SchemaProps: spec.SchemaProps{
								Description: "RegisterNode enables automatic registration with the apiserver.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"nodeStatusUpdateFrequency": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeStatusUpdateFrequency Specifies how often kubelet posts node status to master (default 10s) must work with nodeMonitorGracePeriod in KubeControllerManagerConfig.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"clusterDomain": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterDomain is the DNS domain for this cluster",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"clusterDNS": {
							SchemaProps: spec.SchemaProps{
								Description: "ClusterDNS is the IP address for a cluster DNS server",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"networkPluginName": {
							SchemaProps: spec.SchemaProps{
								Description: "NetworkPluginName is the name of the network plugin to be invoked for various events in kubelet/pod lifecycle",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cloudProvider": {
							SchemaProps: spec.SchemaProps{
								Description: "CloudProvider is the provider for cloud services.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"kubeletCgroups": {
							SchemaProps: spec.SchemaProps{
								Description: "KubeletCgroups is the absolute name of cgroups to isolate the kubelet in.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"runtimeCgroups": {
							SchemaProps: spec.SchemaProps{
								Description: "Cgroups that container runtime is expected to be isolated in.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"readOnlyPort": {
							SchemaProps: spec.SchemaProps{
								Description: "ReadOnlyPort is the port used by the kubelet api for read-only access (default 10255)",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"systemCgroups": {
							SchemaProps: spec.SchemaProps{
								Description: "SystemCgroups is absolute name of cgroups in which to place all non-kernel processes that are not already in a container. Empty for no container. Rolling back the flag requires a reboot.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"cgroupRoot": {
							SchemaProps: spec.SchemaProps{
								Description: "cgroupRoot is the root cgroup to use for pods. This is handled by the container runtime on a best effort basis.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"configureCbr0": {
							SchemaProps: spec.SchemaProps{
								Description: "configureCBR0 enables the kublet to configure cbr0 based on Node.Spec.PodCIDR.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"hairpinMode": {
							SchemaProps: spec.SchemaProps{
								Description: "How should the kubelet configure the container bridge for hairpin packets. Setting this flag allows endpoints in a Service to loadbalance back to themselves if they should try to access their own Service. Values:\n  \"promiscuous-bridge\": make the container bridge promiscuous.\n  \"hairpin-veth\":       set the hairpin flag on container veth interfaces.\n  \"none\":               do nothing.\nSetting --configure-cbr0 to false implies that to achieve hairpin NAT one must set --hairpin-mode=veth-flag, because bridge assumes the existence of a container bridge named cbr0.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"babysitDaemons": {
							SchemaProps: spec.SchemaProps{
								Description: "The node has babysitter process monitoring docker and kubelet. Removed as of 1.7",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"maxPods": {
							SchemaProps: spec.SchemaProps{
								Description: "MaxPods is the number of pods that can run on this Kubelet.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"nvidiaGPUs": {
							SchemaProps: spec.SchemaProps{
								Description: "NvidiaGPUs is the number of NVIDIA GPU devices on this node.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"podCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "PodCIDR is the CIDR to use for pod IP addresses, only used in standalone mode. In cluster mode, this is obtained from the master.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"resolvConf": {
							SchemaProps: spec.SchemaProps{
								Description: "ResolverConfig is the resolver configuration file used as the basis for the container DNS resolution configuration.\"), []",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"reconcileCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "ReconcileCIDR is Reconcile node CIDR with the CIDR specified by the API server. No-op if register-node or configure-cbr0 is false.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"registerSchedulable": {
							SchemaProps: spec.SchemaProps{
								Description: "registerSchedulable tells the kubelet to register the node as schedulable. No-op if register-node is false.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"serializeImagePulls": {
							SchemaProps: spec.SchemaProps{
								Description: "// SerializeImagePulls when enabled, tells the Kubelet to pull images one // at a time. We recommend *not* changing the default value on nodes that // run docker daemon with version  < 1.9 or an Aufs storage backend. // Issue #10959 has more details.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"nodeLabels": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeLabels to add when registering the node in the cluster.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"nonMasqueradeCIDR": {
							SchemaProps: spec.SchemaProps{
								Description: "NonMasqueradeCIDR configures masquerading: traffic to IPs outside this range will use IP masquerade.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"enableCustomMetrics": {
							SchemaProps: spec.SchemaProps{
								Description: "Enable gathering custom metrics.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"networkPluginMTU": {
							SchemaProps: spec.SchemaProps{
								Description: "NetworkPluginMTU is the MTU to be passed to the network plugin, and overrides the default MTU for cases where it cannot be automatically computed (such as IPSEC).",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"imageGCHighThresholdPercent": {
							SchemaProps: spec.SchemaProps{
								Description: "ImageGCHighThresholdPercent is the percent of disk usage after which image garbage collection is always run.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"imageGCLowThresholdPercent": {
							SchemaProps: spec.SchemaProps{
								Description: "ImageGCLowThresholdPercent is the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"imagePullProgressDeadline": {
							SchemaProps: spec.SchemaProps{
								Description: "ImagePullProgressDeadline is the timeout for image pulls If no pulling progress is made before this deadline, the image pulling will be cancelled. (default 1m0s)",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"evictionHard": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of hard eviction expressions.  For example, 'memory.available<300Mi'.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"evictionSoft": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of soft eviction expressions.  For example, 'memory.available<300Mi'.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"evictionSoftGracePeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of grace periods for each soft eviction signal.  For example, 'memory.available=30s'.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"evictionPressureTransitionPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"evictionMaxPodGracePeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"evictionMinimumReclaim": {
							SchemaProps: spec.SchemaProps{
								Description: "Comma-delimited list of minimum reclaims (e.g. imagefs.available=2Gi) that describes the minimum amount of resource the kubelet will reclaim when performing a pod eviction if that resource is under pressure.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"volumePluginDirectory": {
							SchemaProps: spec.SchemaProps{
								Description: "The full path of the directory in which to search for additional third party volume plugins",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"taints": {
							SchemaProps: spec.SchemaProps{
								Description: "Taints to add when registering a node in the cluster",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"featureGates": {
							SchemaProps: spec.SchemaProps{
								Description: "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"kubeReserved": {
							SchemaProps: spec.SchemaProps{
								Description: "Resource reservation for kubernetes system daemons like the kubelet, container runtime, node problem detector, etc.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"kubeReservedCgroup": {
							SchemaProps: spec.SchemaProps{
								Description: "Control group for kube daemons.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"systemReserved": {
							SchemaProps: spec.SchemaProps{
								Description: "Capture resource reservation for OS system daemons like sshd, udev, etc.",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"systemReservedCgroup": {
							SchemaProps: spec.SchemaProps{
								Description: "Parent control group for OS system daemons.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"enforceNodeAllocatable": {
							SchemaProps: spec.SchemaProps{
								Description: "Enforce Allocatable across pods whenever the overall usage across all pods exceeds Allocatable.",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"runtimeRequestTimeout": {
							SchemaProps: spec.SchemaProps{
								Description: "RuntimeRequestTimeout is timeout for runtime requests on - pull, logs, exec and attach",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"volumeStatsAggPeriod": {
							SchemaProps: spec.SchemaProps{
								Description: "VolumeStatsAggPeriod is the interval for kubelet to calculate and cache the volume disk usage for all pods and volumes",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"failSwapOn": {
							SchemaProps: spec.SchemaProps{
								Description: "Tells the Kubelet to fail to start if swap is enabled on the node.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"experimental_allowed_unsafe_sysctls": {
							SchemaProps: spec.SchemaProps{
								Description: "ExperimentalAllowedUnsafeSysctls are passed to the kubelet config to whitelist allowable sysctls",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"streamingConnectionIdleTimeout": {
							SchemaProps: spec.SchemaProps{
								Description: "StreamingConnectionIdleTimeout is the maximum time a streaming connection can be idle before the connection is automatically closed",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"dockerDisableSharedPID": {
							SchemaProps: spec.SchemaProps{
								Description: "DockerDisableSharedPID uses a shared PID namespace for containers in a pod.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"rootDir": {
							SchemaProps: spec.SchemaProps{
								Description: "RootDir is the directory path for managing kubelet files (volume mounts,etc)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"authenticationTokenWebhook": {
							SchemaProps: spec.SchemaProps{
								Description: "AuthenticationTokenWebhook uses the TokenReview API to determine authentication for bearer tokens.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
						"authenticationTokenWebhookCacheTtl": {
							SchemaProps: spec.SchemaProps{
								Description: "AuthenticationTokenWebhook sets the duration to cache responses from the webhook token authenticator. Default is 2m. (default 2m0s)",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KubenetNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KubenetNetworkingSpec is the specification for kubenet networking, largely integrated but intended to replace classic",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.KuberouterNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "KuberouterNetworkingSpec declares that we want Kube-router networking",
					Properties:  map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.LeaderElectionConfiguration": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "LeaderElectionConfiguration defines the configuration of leader election clients for components that can run with leader election enabled.",
					Properties: map[string]spec.Schema{
						"leaderElect": {
							SchemaProps: spec.SchemaProps{
								Description: "leaderElect enables a leader election client to gain leadership before executing the main loop. Enable this when running replicated components for high availability.",
								Type:        []string{"boolean"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.LoadBalancer": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "LoadBalancers defines a load balancer",
					Properties: map[string]spec.Schema{
						"loadBalancerName": {
							SchemaProps: spec.SchemaProps{
								Description: "LoadBalancerName to associate with this instance group (AWS ELB)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"targetGroupArn": {
							SchemaProps: spec.SchemaProps{
								Description: "TargetGroupARN to associate with this instance group (AWS ALB/NLB)",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.LoadBalancerAccessSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "LoadBalancerAccessSpec provides configuration details related to API LoadBalancer and its access",
					Properties: map[string]spec.Schema{
						"type": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
						"idleTimeoutSeconds": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int64",
							},
						},
						"additionalSecurityGroups": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"useForInternalApi": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"boolean"},
								Format: "",
							},
						},
						"sslCertificate": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.NetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "NetworkingSpec allows selection and configuration of a networking plugin",
					Properties: map[string]spec.Schema{
						"classic": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.ClassicNetworkingSpec"),
							},
						},
						"kubenet": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KubenetNetworkingSpec"),
							},
						},
						"external": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.ExternalNetworkingSpec"),
							},
						},
						"cni": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.CNINetworkingSpec"),
							},
						},
						"kopeio": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KopeioNetworkingSpec"),
							},
						},
						"weave": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.WeaveNetworkingSpec"),
							},
						},
						"flannel": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.FlannelNetworkingSpec"),
							},
						},
						"calico": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.CalicoNetworkingSpec"),
							},
						},
						"canal": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.CanalNetworkingSpec"),
							},
						},
						"kuberouter": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.KuberouterNetworkingSpec"),
							},
						},
						"romana": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.RomanaNetworkingSpec"),
							},
						},
						"amazonvpc": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.AmazonVPCNetworkingSpec"),
							},
						},
						"cilium": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.CiliumNetworkingSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.AmazonVPCNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.CNINetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.CalicoNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.CanalNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.CiliumNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.ClassicNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.ExternalNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.FlannelNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.KopeioNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.KubenetNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.KuberouterNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.RomanaNetworkingSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.WeaveNetworkingSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.NodeAuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "NodeAuthorizationSpec is used to node authorization",
					Properties: map[string]spec.Schema{
						"nodeAuthorizer": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeAuthorizer defined the configuration for the node authorizer",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.NodeAuthorizerSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.NodeAuthorizerSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.NodeAuthorizerSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "NodeAuthorizerSpec defines the configuration for a node authorizer",
					Properties: map[string]spec.Schema{
						"authorizer": {
							SchemaProps: spec.SchemaProps{
								Description: "Authorizer is the authorizer to use",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"features": {
							SchemaProps: spec.SchemaProps{
								Description: "Features is a series of authorizer features to enable or disable",
								Type:        []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
						"image": {
							SchemaProps: spec.SchemaProps{
								Description: "Image is the location of container",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"nodeURL": {
							SchemaProps: spec.SchemaProps{
								Description: "NodeURL is the node authorization service url",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"port": {
							SchemaProps: spec.SchemaProps{
								Description: "Port is the port the service is running on the master",
								Type:        []string{"integer"},
								Format:      "int32",
							},
						},
						"timeout": {
							SchemaProps: spec.SchemaProps{
								Description: "Timeout the max time for authorization request",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
						"tokenTTL": {
							SchemaProps: spec.SchemaProps{
								Description: "TokenTTL is the max ttl for an issued token",
								Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.RBACAuthorizationSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.RomanaNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "RomanaNetworkingSpec declares that we want Romana networking",
					Properties: map[string]spec.Schema{
						"daemonServiceIP": {
							SchemaProps: spec.SchemaProps{
								Description: "DaemonServiceIP is the Kubernetes Service IP for the romana-daemon pod",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"etcdServiceIP": {
							SchemaProps: spec.SchemaProps{
								Description: "EtcdServiceIP is the Kubernetes Service IP for the etcd backend used by Romana",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredential": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "SSHCredential represent a set of kops secrets",
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
							},
						},
						"spec": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredentialSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta", "k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredentialSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredentialList": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"kind": {
							SchemaProps: spec.SchemaProps{
								Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"apiVersion": {
							SchemaProps: spec.SchemaProps{
								Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"metadata": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
							},
						},
						"items": {
							SchemaProps: spec.SchemaProps{
								Type: []string{"array"},
								Items: &spec.SchemaOrArray{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredential"),
										},
									},
								},
							},
						},
					},
					Required: []string{"items"},
				},
			},
			Dependencies: []string{
				"k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta", "k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredential"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.SSHCredentialSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"publicKey": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"string"},
								Format: "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.TargetSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "TargetSpec allows for specifying target config in an extensible way",
					Properties: map[string]spec.Schema{
						"terraform": {
							SchemaProps: spec.SchemaProps{
								Ref: ref("k8s.io/kops/pkg/apis/kops/v1alpha1.TerraformSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.TerraformSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.TerraformSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "TerraformSpec allows us to specify terraform config in an extensible way",
					Properties: map[string]spec.Schema{
						"providerExtraConfig": {
							SchemaProps: spec.SchemaProps{
								Description: "ProviderExtraConfig contains key/value pairs to add to the rendered terraform \"provider\" block",
								Type:        []string{"object"},
								AdditionalProperties: &spec.SchemaOrBool{
									Schema: &spec.Schema{
										SchemaProps: spec.SchemaProps{
											Type:   []string{"string"},
											Format: "",
										},
									},
								},
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.TopologySpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Properties: map[string]spec.Schema{
						"masters": {
							SchemaProps: spec.SchemaProps{
								Description: "The environment to launch the Kubernetes masters in public|private",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"nodes": {
							SchemaProps: spec.SchemaProps{
								Description: "The environment to launch the Kubernetes nodes in public|private",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"bastion": {
							SchemaProps: spec.SchemaProps{
								Description: "Bastion provide an external facing point of entry into a network containing private network instances. This host can provide a single point of fortification or audit and can be started and stopped to enable or disable inbound SSH communication from the Internet, some call bastion as the \"jump server\".",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.BastionSpec"),
							},
						},
						"dns": {
							SchemaProps: spec.SchemaProps{
								Description: "DNS configures options relating to DNS, in particular whether we use a public or a private hosted zone",
								Ref:         ref("k8s.io/kops/pkg/apis/kops/v1alpha1.DNSSpec"),
							},
						},
					},
				},
			},
			Dependencies: []string{
				"k8s.io/kops/pkg/apis/kops/v1alpha1.BastionSpec", "k8s.io/kops/pkg/apis/kops/v1alpha1.DNSSpec"},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.UserData": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "UserData defines a user-data section",
					Properties: map[string]spec.Schema{
						"name": {
							SchemaProps: spec.SchemaProps{
								Description: "Name is the name of the user-data",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"type": {
							SchemaProps: spec.SchemaProps{
								Description: "Type is the type of user-data",
								Type:        []string{"string"},
								Format:      "",
							},
						},
						"content": {
							SchemaProps: spec.SchemaProps{
								Description: "Content is the user-data content",
								Type:        []string{"string"},
								Format:      "",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
		"k8s.io/kops/pkg/apis/kops/v1alpha1.WeaveNetworkingSpec": {
			Schema: spec.Schema{
				SchemaProps: spec.SchemaProps{
					Description: "WeaveNetworkingSpec declares that we want Weave networking",
					Properties: map[string]spec.Schema{
						"mtu": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
						"connLimit": {
							SchemaProps: spec.SchemaProps{
								Type:   []string{"integer"},
								Format: "int32",
							},
						},
					},
				},
			},
			Dependencies: []string{},
		},
	}
}
