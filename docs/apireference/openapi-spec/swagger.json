{
  "swagger": "2.0",
  "info": {
    "title": "Kops",
    "version": "v1alpha2"
  },
  "paths": {},
  "definitions": {
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AccessSpec": {
      "description": "AccessSpec provides configuration details related to kubeapi dns and ELB access",
      "properties": {
        "dns": {
          "description": "DNS will be used to provide config on kube-apiserver elb dns",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.DNSAccessSpec"
        },
        "loadBalancer": {
          "description": "LoadBalancer is the configuration for the kube-apiserver ELB",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.LoadBalancerAccessSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AddonSpec": {
      "description": "AddonSpec defines an addon that we want to install in the cluster",
      "properties": {
        "manifest": {
          "description": "Manifest is a path to the manifest that defines the addon",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AlwaysAllowAuthorizationSpec": {},
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AmazonVPCNetworkingSpec": {
      "description": "AmazonVPCNetworkingSpec declares that we want Amazon VPC CNI networking",
      "properties": {
        "imageName": {
          "description": "The container image name to use, which by default is: 602401143452.dkr.ecr.us-west-2.amazonaws.com/amazon-k8s-cni:1.0.0",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.Assets": {
      "description": "Assets defined the privately hosted assets",
      "properties": {
        "containerProxy": {
          "description": "ContainerProxy is a url for a pull-through proxy of a docker registry",
          "type": "string"
        },
        "containerRegistry": {
          "description": "ContainerRegistry is a url for to a docker registry",
          "type": "string"
        },
        "fileRepository": {
          "description": "FileRepository is the url for a private file serving repository",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AuthenticationSpec": {
      "properties": {
        "aws": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AwsAuthenticationSpec"
        },
        "kopeio": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KopeioAuthenticationSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AuthorizationSpec": {
      "properties": {
        "alwaysAllow": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AlwaysAllowAuthorizationSpec"
        },
        "rbac": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.RBACAuthorizationSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.AwsAuthenticationSpec": {},
    "io.k8s.kops.pkg.apis.kops.v1alpha2.BastionSpec": {
      "properties": {
        "bastionPublicName": {
          "type": "string"
        },
        "idleTimeoutSeconds": {
          "description": "IdleTimeoutSeconds is the bastion's Loadbalancer idle timeout",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.CNINetworkingSpec": {
      "description": "CNINetworkingSpec is the specification for networking that is implemented by a Daemonset Networking is not managed by kops - we can create options here that directly configure e.g. weave but this is useful for arbitrary network modes or for modes that don't need additional configuration.",
      "properties": {
        "usesSecondaryIP": {
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.CalicoNetworkingSpec": {
      "description": "CalicoNetworkingSpec declares that we want Calico networking",
      "properties": {
        "crossSubnet": {
          "type": "boolean"
        },
        "logSeverityScreen": {
          "description": "LogSeverityScreen lets us set the desired log level. (Default: info)",
          "type": "string"
        },
        "mtu": {
          "description": "MTU to be set in the cni-network-config for calico.",
          "type": "integer",
          "format": "int32"
        },
        "prometheusGoMetricsEnabled": {
          "description": "PrometheusGoMetricsEnabled enables Prometheus Go runtime metrics collection",
          "type": "boolean"
        },
        "prometheusMetricsEnabled": {
          "description": "PrometheusMetricsEnabled can be set to enable the experimental Prometheus metrics server (default: false)",
          "type": "boolean"
        },
        "prometheusMetricsPort": {
          "description": "PrometheusMetricsPort is the TCP port that the experimental Prometheus metrics server should bind to (default: 9091)",
          "type": "integer",
          "format": "int32"
        },
        "prometheusProcessMetricsEnabled": {
          "description": "PrometheusProcessMetricsEnabled enables Prometheus process metrics collection",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.CanalNetworkingSpec": {
      "description": "CanalNetworkingSpec declares that we want Canal networking",
      "properties": {
        "chainInsertMode": {
          "description": "ChainInsertMode controls whether Felix inserts rules to the top of iptables chains, or appends to the bottom. Leaving the default option is safest to prevent accidentally breaking connectivity. Default: 'insert' (other options: 'append')",
          "type": "string"
        },
        "defaultEndpointToHostAction": {
          "description": "DefaultEndpointToHostAction allows users to configure the default behaviour for traffic between pod to host after calico rules have been processed. Default: ACCEPT (other options: DROP, RETURN)",
          "type": "string"
        },
        "logSeveritySys": {
          "description": "LogSeveritySys the severity to set for logs which are sent to syslog Default: INFO (other options: DEBUG, WARNING, ERROR, CRITICAL, NONE)",
          "type": "string"
        },
        "prometheusGoMetricsEnabled": {
          "description": "PrometheusGoMetricsEnabled enables Prometheus Go runtime metrics collection",
          "type": "boolean"
        },
        "prometheusMetricsEnabled": {
          "description": "PrometheusMetricsEnabled can be set to enable the experimental Prometheus metrics server (default: false)",
          "type": "boolean"
        },
        "prometheusMetricsPort": {
          "description": "PrometheusMetricsPort is the TCP port that the experimental Prometheus metrics server should bind to (default: 9091)",
          "type": "integer",
          "format": "int32"
        },
        "prometheusProcessMetricsEnabled": {
          "description": "PrometheusProcessMetricsEnabled enables Prometheus process metrics collection",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.CiliumNetworkingSpec": {
      "description": "CiliumNetworkingSpec declares that we want Cilium networking",
      "properties": {
        "accessLog": {
          "type": "string"
        },
        "agentLabels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "allowLocalhost": {
          "type": "string"
        },
        "autoIpv6NodeRoutes": {
          "type": "boolean"
        },
        "bpfRoot": {
          "type": "string"
        },
        "containerRuntime": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "containerRuntimeEndpoint": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "debug": {
          "type": "boolean"
        },
        "debugVerbose": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "device": {
          "type": "string"
        },
        "disableConntrack": {
          "type": "boolean"
        },
        "disableIpv4": {
          "type": "boolean"
        },
        "disableK8sServices": {
          "type": "boolean"
        },
        "disableMasquerade": {
          "type": "boolean"
        },
        "enablePolicy": {
          "type": "string"
        },
        "enableTracing": {
          "type": "boolean"
        },
        "envoyLog": {
          "type": "string"
        },
        "ipv4ClusterCidrMaskSize": {
          "type": "integer",
          "format": "int32"
        },
        "ipv4Node": {
          "type": "string"
        },
        "ipv4Range": {
          "type": "string"
        },
        "ipv4ServiceRange": {
          "type": "string"
        },
        "ipv6ClusterAllocCidr": {
          "type": "string"
        },
        "ipv6Node": {
          "type": "string"
        },
        "ipv6Range": {
          "type": "string"
        },
        "ipv6ServiceRange": {
          "type": "string"
        },
        "k8sApiServer": {
          "type": "string"
        },
        "k8sKubeconfigPath": {
          "type": "string"
        },
        "keepBpfTemplates": {
          "type": "boolean"
        },
        "keepConfig": {
          "type": "boolean"
        },
        "labelPrefixFile": {
          "type": "string"
        },
        "labels": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "lb": {
          "type": "string"
        },
        "libDir": {
          "type": "string"
        },
        "logDriver": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "logOpt": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "logstash": {
          "type": "boolean"
        },
        "logstashAgent": {
          "type": "string"
        },
        "logstashProbeTimer": {
          "type": "integer",
          "format": "int64"
        },
        "nat46Range": {
          "type": "string"
        },
        "pprof": {
          "type": "boolean"
        },
        "prefilterDevice": {
          "type": "string"
        },
        "prometheusServeAddr": {
          "type": "string"
        },
        "restore": {
          "type": "boolean"
        },
        "singleClusterRoute": {
          "type": "boolean"
        },
        "socketPath": {
          "type": "string"
        },
        "stateDir": {
          "type": "string"
        },
        "tracePayloadlen": {
          "type": "integer",
          "format": "int32"
        },
        "tunnel": {
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ClassicNetworkingSpec": {
      "description": "ClassicNetworkingSpec is the specification of classic networking mode, integrated into kubernetes"
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.CloudConfiguration": {
      "description": "CloudConfiguration defines the cloud provider configuration",
      "properties": {
        "disableSecurityGroupIngress": {
          "description": "AWS cloud-config options",
          "type": "boolean"
        },
        "elbSecurityGroup": {
          "type": "string"
        },
        "multizone": {
          "description": "GCE cloud-config options",
          "type": "boolean"
        },
        "nodeInstancePrefix": {
          "type": "string"
        },
        "nodeTags": {
          "type": "string"
        },
        "vSphereCoreDNSServer": {
          "type": "string"
        },
        "vSphereDatacenter": {
          "type": "string"
        },
        "vSphereDatastore": {
          "type": "string"
        },
        "vSpherePassword": {
          "type": "string"
        },
        "vSphereResourcePool": {
          "type": "string"
        },
        "vSphereServer": {
          "type": "string"
        },
        "vSphereUsername": {
          "description": "vSphere cloud-config specs",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.CloudControllerManagerConfig": {
      "description": "CloudControllerManagerConfig is the configuration of the cloud controller",
      "properties": {
        "allocateNodeCIDRs": {
          "description": "AllocateNodeCIDRs enables CIDRs for Pods to be allocated and, if ConfigureCloudRoutes is true, to be set on the cloud provider.",
          "type": "boolean"
        },
        "cidrAllocatorType": {
          "description": "CIDRAllocatorType specifies the type of CIDR allocator to use.",
          "type": "string"
        },
        "cloudProvider": {
          "description": "CloudProvider is the provider for cloud services.",
          "type": "string"
        },
        "clusterCIDR": {
          "description": "ClusterCIDR is CIDR Range for Pods in cluster.",
          "type": "string"
        },
        "clusterName": {
          "description": "ClusterName is the instance prefix for the cluster.",
          "type": "string"
        },
        "configureCloudRoutes": {
          "description": "ConfigureCloudRoutes enables CIDRs allocated with to be configured on the cloud provider.",
          "type": "boolean"
        },
        "image": {
          "description": "Image is the OCI image of the cloud controller manager.",
          "type": "string"
        },
        "leaderElection": {
          "description": "LeaderElection defines the configuration of leader election client.",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.LeaderElectionConfiguration"
        },
        "logLevel": {
          "description": "LogLevel is the verbosity of the logs.",
          "type": "integer",
          "format": "int32"
        },
        "master": {
          "description": "Master is the url for the kube api master.",
          "type": "string"
        },
        "useServiceAccountCredentials": {
          "description": "UseServiceAccountCredentials controls whether we use individual service account credentials for each controller.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.Cluster": {
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.ClusterSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ClusterList": {
      "description": "ClusterList is a list of clusters",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.Cluster"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ClusterSpec": {
      "description": "ClusterSpec defines the configuration for a cluster",
      "properties": {
        "additionalNetworkCIDRs": {
          "description": "AdditionalNetworkCIDRs is a list of additional CIDR used for the AWS VPC or otherwise allocated to k8s. This is a real CIDR, not the internal k8s network On AWS, it maps to any additional CIDRs added to a VPC.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "additionalPolicies": {
          "description": "Additional policies to add for roles",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "additionalSans": {
          "description": "AdditionalSANs adds additional Subject Alternate Names to apiserver cert that kops generates",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "addons": {
          "description": "Additional addons that should be installed on the cluster",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AddonSpec"
          }
        },
        "api": {
          "description": "API field controls how the API is exposed outside the cluster",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AccessSpec"
        },
        "assets": {
          "description": "Alternative locations for files and containers",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.Assets"
        },
        "authentication": {
          "description": "Authentication field controls how the cluster is configured for authentication",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AuthenticationSpec"
        },
        "authorization": {
          "description": "Authorization field controls how the cluster is configured for authorization",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AuthorizationSpec"
        },
        "channel": {
          "description": "The Channel we are following",
          "type": "string"
        },
        "cloudConfig": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.CloudConfiguration"
        },
        "cloudControllerManager": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.CloudControllerManagerConfig"
        },
        "cloudLabels": {
          "description": "Tags for AWS resources",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "cloudProvider": {
          "description": "The CloudProvider to use (aws or gce)",
          "type": "string"
        },
        "clusterDNSDomain": {
          "description": "ClusterDNSDomain is the suffix we use for internal DNS names (normally cluster.local)",
          "type": "string"
        },
        "configBase": {
          "description": "ConfigBase is the path where we store configuration for the cluster This might be different that the location when the cluster spec itself is stored, both because this must be accessible to the cluster, and because it might be on a different cloud or storage system (etcd vs S3)",
          "type": "string"
        },
        "configStore": {
          "description": "ConfigStore is the VFS path to where the configuration (Cluster, InstanceGroups etc) is stored",
          "type": "string"
        },
        "dnsZone": {
          "description": "DNSZone is the DNS zone we should use when configuring DNS This is because some clouds let us define a managed zone foo.bar, and then have kubernetes.dev.foo.bar, without needing to define dev.foo.bar as a hosted zone. DNSZone will probably be a suffix of the MasterPublicName and MasterInternalName Note that DNSZone can either by the host name of the zone (containing dots), or can be an identifier for the zone.",
          "type": "string"
        },
        "docker": {
          "description": "Component configurations",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.DockerConfig"
        },
        "egressProxy": {
          "description": "HTTPProxy defines connection information to support use of a private cluster behind an forward HTTP Proxy",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.EgressProxySpec"
        },
        "encryptionConfig": {
          "description": "EncryptionConfig holds the encryption config",
          "type": "boolean"
        },
        "etcdClusters": {
          "description": "EtcdClusters stores the configuration for each cluster",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdClusterSpec"
          }
        },
        "externalDns": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.ExternalDNSConfig"
        },
        "fileAssets": {
          "description": "A collection of files assets for deployed cluster wide",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.FileAssetSpec"
          }
        },
        "hooks": {
          "description": "Hooks for custom actions e.g. on first installation",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.HookSpec"
          }
        },
        "iam": {
          "description": "IAM field adds control over the IAM security policies applied to resources",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.IAMSpec"
        },
        "isolateMasters": {
          "description": "IsolatesMasters determines whether we should lock down masters so that they are not on the pod network. true is the kube-up behaviour, but it is very surprising: it means that daemonsets only work on the master if they have hostNetwork=true. false is now the default, and it will:\n * give the master a normal PodCIDR\n * run kube-proxy on the master\n * enable debugging handlers on the master, so kubectl logs works",
          "type": "boolean"
        },
        "keyStore": {
          "description": "KeyStore is the VFS path to where SSL keys and certificates are stored",
          "type": "string"
        },
        "kubeAPIServer": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeAPIServerConfig"
        },
        "kubeControllerManager": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeControllerManagerConfig"
        },
        "kubeDNS": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeDNSConfig"
        },
        "kubeProxy": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeProxyConfig"
        },
        "kubeScheduler": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeSchedulerConfig"
        },
        "kubelet": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeletConfigSpec"
        },
        "kubernetesApiAccess": {
          "description": "KubernetesAPIAccess determines the permitted access to the API endpoints (master HTTPS) Currently only a single CIDR is supported (though a richer grammar could be added in future)",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "kubernetesVersion": {
          "description": "The version of kubernetes to install (optional, and can be a \"spec\" like stable)",
          "type": "string"
        },
        "masterInternalName": {
          "description": "MasterInternalName is the internal DNS name for the master nodes",
          "type": "string"
        },
        "masterKubelet": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeletConfigSpec"
        },
        "masterPublicName": {
          "description": "MasterPublicName is the external DNS name for the master nodes",
          "type": "string"
        },
        "networkCIDR": {
          "description": "NetworkCIDR is the CIDR used for the AWS VPC / GCE Network, or otherwise allocated to k8s This is a real CIDR, not the internal k8s network On AWS, it maps to the VPC CIDR.  It is not required on GCE.",
          "type": "string"
        },
        "networkID": {
          "description": "NetworkID is an identifier of a network, if we want to reuse/share an existing network (e.g. an AWS VPC)",
          "type": "string"
        },
        "networking": {
          "description": "Networking configuration",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.NetworkingSpec"
        },
        "nodeAuthorization": {
          "description": "NodeAuthorization defined the custom node authorization configuration",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.NodeAuthorizationSpec"
        },
        "nodePortAccess": {
          "description": "NodePortAccess is a list of the CIDRs that can access the node ports range (30000-32767).",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "nonMasqueradeCIDR": {
          "description": "MasterIPRange                 string `json:\",omitempty\"` NonMasqueradeCIDR is the CIDR for the internal k8s network (on which pods \u0026 services live) It cannot overlap ServiceClusterIPRange",
          "type": "string"
        },
        "project": {
          "description": "Project is the cloud project we should use, required on GCE",
          "type": "string"
        },
        "secretStore": {
          "description": "SecretStore is the VFS path to where secrets are stored",
          "type": "string"
        },
        "serviceClusterIPRange": {
          "description": "ServiceClusterIPRange is the CIDR, from the internal network, where we allocate IPs for services",
          "type": "string"
        },
        "sshAccess": {
          "description": "SSHAccess determines the permitted access to SSH Currently only a single CIDR is supported (though a richer grammar could be added in future)",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "sshKeyName": {
          "description": "SSHKeyName specifies a preexisting SSH key to use",
          "type": "string"
        },
        "subnets": {
          "description": "Configuration of subnets we are targeting",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.ClusterSubnetSpec"
          }
        },
        "target": {
          "description": "Target allows for us to nest extra config for targets such as terraform",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.TargetSpec"
        },
        "topology": {
          "description": "Topology defines the type of network topology to use on the cluster - default public This is heavily weighted towards AWS for the time being, but should also be agnostic enough to port out to GCE later if needed",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.TopologySpec"
        },
        "updatePolicy": {
          "description": "UpdatePolicy determines the policy for applying upgrades automatically. Valid values:\n  'external' do not apply updates automatically - they are applied manually or by an external system\n  missing: default policy (currently OS security upgrades that do not require a reboot)",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ClusterSubnetSpec": {
      "properties": {
        "cidr": {
          "type": "string"
        },
        "egress": {
          "description": "Egress defines the method of traffic egress for this subnet",
          "type": "string"
        },
        "id": {
          "description": "ProviderID is the cloud provider id for the objects associated with the zone (the subnet on AWS)",
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "publicIP": {
          "description": "PublicIP to attach to NatGateway",
          "type": "string"
        },
        "region": {
          "description": "Region is the region the subnet is in, set for subnets that are regionally scoped",
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "zone": {
          "description": "Zone is the zone the subnet is in, set for subnets that are zonally scoped",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.DNSAccessSpec": {},
    "io.k8s.kops.pkg.apis.kops.v1alpha2.DNSSpec": {
      "properties": {
        "type": {
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.DockerConfig": {
      "description": "DockerConfig is the configuration for docker",
      "properties": {
        "authorizationPlugins": {
          "description": "AuthorizationPlugins is a list of authorization plugins",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "bridge": {
          "description": "Bridge is the network interface containers should bind onto",
          "type": "string"
        },
        "bridgeIP": {
          "description": "BridgeIP is a specific IP address and netmask for the docker0 bridge, using standard CIDR notation",
          "type": "string"
        },
        "dataRoot": {
          "description": "DataRoot is the root directory of persistent docker state (default \"/var/lib/docker\")",
          "type": "string"
        },
        "defaultUlimit": {
          "description": "DefaultUlimit is the ulimits for containers",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "execRoot": {
          "description": "ExecRoot is the root directory for execution state files (default \"/var/run/docker\")",
          "type": "string"
        },
        "hosts": {
          "description": "Hosts enables you to configure the endpoints the docker daemon listens on i.e tcp://0.0.0.0.2375 or unix:///var/run/docker.sock etc",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "insecureRegistry": {
          "description": "InsecureRegistry enable insecure registry communication @question according to dockers this a list??",
          "type": "string"
        },
        "ipMasq": {
          "description": "IPMasq enables ip masquerading for containers",
          "type": "boolean"
        },
        "ipTables": {
          "description": "IPtables enables addition of iptables rules",
          "type": "boolean"
        },
        "liveRestore": {
          "description": "LiveRestore enables live restore of docker when containers are still running",
          "type": "boolean"
        },
        "logDriver": {
          "description": "LogDriver is the default driver for container logs (default \"json-file\")",
          "type": "string"
        },
        "logLevel": {
          "description": "LogLevel is the logging level (\"debug\", \"info\", \"warn\", \"error\", \"fatal\") (default \"info\")",
          "type": "string"
        },
        "logOpt": {
          "description": "Logopt is a series of options given to the log driver options for containers",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mtu": {
          "description": "MTU is the containers network MTU",
          "type": "integer",
          "format": "int32"
        },
        "registryMirrors": {
          "description": "RegistryMirrors is a referred list of docker registry mirror",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "storage": {
          "description": "Storage is the docker storage driver to use",
          "type": "string"
        },
        "storageOpts": {
          "description": "StorageOpts is a series of options passed to the storage driver",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "userNamespaceRemap": {
          "description": "UserNamespaceRemap sets the user namespace remapping option for the docker daemon",
          "type": "string"
        },
        "version": {
          "description": "Version is consumed by the nodeup and used to pick the docker version",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.EgressProxySpec": {
      "properties": {
        "excludes": {
          "type": "string"
        },
        "httpProxy": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.HTTPProxy"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdBackupSpec": {
      "description": "EtcdBackupSpec describes how we want to do backups of etcd",
      "properties": {
        "backupStore": {
          "description": "BackupStore is the VFS path where we will read/write backup data",
          "type": "string"
        },
        "image": {
          "description": "Image is the etcd backup manager image to use.  Setting this will create a sidecar container in the etcd pod with the specified image.",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdClusterSpec": {
      "description": "EtcdClusterSpec is the etcd cluster specification",
      "properties": {
        "backups": {
          "description": "Backups describes how we do backups of etcd",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdBackupSpec"
        },
        "enableEtcdTLS": {
          "description": "EnableEtcdTLS indicates the etcd service should use TLS between peers and clients",
          "type": "boolean"
        },
        "enableTLSAuth": {
          "description": "EnableTLSAuth indicates client and peer TLS auth should be enforced",
          "type": "boolean"
        },
        "etcdMembers": {
          "description": "Members stores the configurations for each member of the cluster (including the data volume)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdMemberSpec"
          }
        },
        "heartbeatInterval": {
          "description": "HeartbeatInterval is the time (in milliseconds) for an etcd heartbeat interval",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "image": {
          "description": "Image is the etcd docker image to use. Setting this will ignore the Version specified.",
          "type": "string"
        },
        "leaderElectionTimeout": {
          "description": "LeaderElectionTimeout is the time (in milliseconds) for an etcd leader election timeout",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "manager": {
          "description": "Manager describes the manager configuration",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdManagerSpec"
        },
        "name": {
          "description": "Name is the name of the etcd cluster (main, events etc)",
          "type": "string"
        },
        "version": {
          "description": "Version is the version of etcd to run i.e. 2.1.2, 3.0.17 etcd",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdManagerSpec": {
      "description": "EtcdManagerSpec describes how we configure the etcd manager",
      "properties": {
        "image": {
          "description": "Image is the etcd manager image to use.",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.EtcdMemberSpec": {
      "description": "EtcdMemberSpec is a specification for a etcd member",
      "properties": {
        "encryptedVolume": {
          "description": "EncryptedVolume indicates you want to encrypt the volume",
          "type": "boolean"
        },
        "instanceGroup": {
          "description": "InstanceGroup is the instanceGroup this volume is associated",
          "type": "string"
        },
        "kmsKeyId": {
          "description": "KmsKeyId is a AWS KMS ID used to encrypt the volume",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of the member within the etcd cluster",
          "type": "string"
        },
        "volumeIops": {
          "description": "If volume type is io1, then we need to specify the number of Iops.",
          "type": "integer",
          "format": "int32"
        },
        "volumeSize": {
          "description": "VolumeSize is the underlining cloud volume size",
          "type": "integer",
          "format": "int32"
        },
        "volumeType": {
          "description": "VolumeType is the underlining cloud storage class",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ExecContainerAction": {
      "description": "ExecContainerAction defines an hood action",
      "properties": {
        "command": {
          "description": "Command is the command supplied to the above image",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "environment": {
          "description": "Environment is a map of environment variables added to the hook",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "image": {
          "description": "Image is the docker image",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ExternalDNSConfig": {
      "description": "ExternalDNSConfig are options of the dns-controller",
      "properties": {
        "disable": {
          "description": "Disable indicates we do not wish to run the dns-controller addon",
          "type": "boolean"
        },
        "watchIngress": {
          "description": "WatchIngress indicates you want the dns-controller to watch and create dns entries for ingress resources",
          "type": "boolean"
        },
        "watchNamespace": {
          "description": "WatchNamespace is namespace to watch, defaults to all (use to control whom can creates dns entries)",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.ExternalNetworkingSpec": {
      "description": "ExternalNetworkingSpec is the specification for networking that is implemented by a Daemonset It also uses kubenet"
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.FileAssetSpec": {
      "description": "FileAssetSpec defines the structure for a file asset",
      "properties": {
        "content": {
          "description": "Content is the contents of the file",
          "type": "string"
        },
        "isBase64": {
          "description": "IsBase64 indicates the contents is base64 encoded",
          "type": "boolean"
        },
        "name": {
          "description": "Name is a shortened reference to the asset",
          "type": "string"
        },
        "path": {
          "description": "Path is the location this file should reside",
          "type": "string"
        },
        "roles": {
          "description": "Roles is a list of roles the file asset should be applied, defaults to all",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.FlannelNetworkingSpec": {
      "description": "FlannelNetworkingSpec declares that we want Flannel networking",
      "properties": {
        "backend": {
          "description": "Backend is the backend overlay type we want to use (vxlan or udp)",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.HTTPProxy": {
      "properties": {
        "host": {
          "type": "string"
        },
        "port": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.HookSpec": {
      "description": "HookSpec is a definition hook",
      "properties": {
        "before": {
          "description": "Before is a series of systemd units which this hook must run before",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "disabled": {
          "description": "Disabled indicates if you want the unit switched off",
          "type": "boolean"
        },
        "execContainer": {
          "description": "ExecContainer is the image itself",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.ExecContainerAction"
        },
        "manifest": {
          "description": "Manifest is a raw systemd unit file",
          "type": "string"
        },
        "name": {
          "description": "Name is an optional name for the hook, otherwise the name is kops-hook-\u003cindex\u003e",
          "type": "string"
        },
        "requires": {
          "description": "Requires is a series of systemd units the action requires",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "roles": {
          "description": "Roles is an optional list of roles the hook should be rolled out to, defaults to all",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "useRawManifest": {
          "description": "UseRawManifest indicates that the contents of Manifest should be used as the contents of the systemd unit, unmodified. Before and Requires are ignored when used together with this value (and validation shouldn't allow them to be set)",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.IAMProfileSpec": {
      "description": "IAMProfileSpec is the AWS IAM Profile to attach to instances in this instance group. Specify the ARN for the IAM instance profile (AWS only).",
      "properties": {
        "profile": {
          "description": "Profile of the cloud group iam profile. In aws this is the arn for the iam instance profile",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.IAMSpec": {
      "description": "IAMSpec adds control over the IAM security policies applied to resources",
      "required": [
        "legacy"
      ],
      "properties": {
        "allowContainerRegistry": {
          "type": "boolean"
        },
        "legacy": {
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.InstanceGroup": {
      "description": "InstanceGroup represents a group of instances (either nodes or masters) with the same configuration",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.InstanceGroupSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.InstanceGroupList": {
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.InstanceGroup"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.InstanceGroupSpec": {
      "description": "InstanceGroupSpec is the specification for an instanceGroup",
      "properties": {
        "additionalSecurityGroups": {
          "description": "AdditionalSecurityGroups attaches additional security groups (e.g. i-123456)",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "additionalUserData": {
          "description": "AdditionalUserData is any additional user-data to be passed to the host",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.UserData"
          }
        },
        "associatePublicIp": {
          "description": "AssociatePublicIP is true if we want instances to have a public IP",
          "type": "boolean"
        },
        "cloudLabels": {
          "description": "CloudLabels indicates the labels for instances in this group, at the AWS level",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "detailedInstanceMonitoring": {
          "description": "DetailedInstanceMonitoring defines if detailed-monitoring is enabled (AWS only)",
          "type": "boolean"
        },
        "externalLoadBalancers": {
          "description": "ExternalLoadBalancers define loadbalancers that should be attached to the instancegroup",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.LoadBalancer"
          }
        },
        "fileAssets": {
          "description": "FileAssets is a collection of file assets for this instance group",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.FileAssetSpec"
          }
        },
        "hooks": {
          "description": "Hooks is a list of hooks for this instanceGroup, note: these can override the cluster wide ones if required",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.HookSpec"
          }
        },
        "iam": {
          "description": "IAMProfileSpec defines the identity of the cloud group iam profile (AWS only).",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.IAMProfileSpec"
        },
        "image": {
          "description": "Image is the instance instance (ami etc) we should use",
          "type": "string"
        },
        "kubelet": {
          "description": "Kubelet overrides kubelet config from the ClusterSpec",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubeletConfigSpec"
        },
        "machineType": {
          "description": "MachineType is the instance class",
          "type": "string"
        },
        "maxPrice": {
          "description": "MaxPrice indicates this is a spot-pricing group, with the specified value as our max-price bid",
          "type": "string"
        },
        "maxSize": {
          "description": "MaxSize is the maximum size of the pool",
          "type": "integer",
          "format": "int32"
        },
        "minSize": {
          "description": "MinSize is the minimum size of the pool",
          "type": "integer",
          "format": "int32"
        },
        "nodeLabels": {
          "description": "NodeLabels indicates the kubernetes labels for nodes in this group",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "role": {
          "description": "Type determines the role of instances in this group: masters or nodes",
          "type": "string"
        },
        "rootVolumeIops": {
          "description": "If volume type is io1, then we need to specify the number of Iops.",
          "type": "integer",
          "format": "int32"
        },
        "rootVolumeOptimization": {
          "description": "RootVolumeOptimization enables EBS optimization for an instance",
          "type": "boolean"
        },
        "rootVolumeSize": {
          "description": "RootVolumeSize is the size of the EBS root volume to use, in GB",
          "type": "integer",
          "format": "int32"
        },
        "rootVolumeType": {
          "description": "RootVolumeType is the type of the EBS root volume to use (e.g. gp2)",
          "type": "string"
        },
        "subnets": {
          "description": "Subnets is the names of the Subnets (as specified in the Cluster) where machines in this instance group should be placed",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "suspendProcesses": {
          "description": "SuspendProcesses disables the listed Scaling Policies",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "taints": {
          "description": "Taints indicates the kubernetes taints for nodes in this group",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tenancy": {
          "description": "Describes the tenancy of the instance group. Can be either default or dedicated. Currently only applies to AWS.",
          "type": "string"
        },
        "zones": {
          "description": "Zones is the names of the Zones where machines in this instance group should be placed This is needed for regional subnets (e.g. GCE), to restrict placement to particular zones",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.Keyset": {
      "description": "Keyset is a set of system keypairs, or other secret material. It is a set to support credential rotation etc.",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KeysetSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KeysetItem": {
      "description": "KeysetItem is an item (keypair or other secret material) in a Keyset",
      "properties": {
        "id": {
          "description": "Id is the unique identifier for this key in the keyset",
          "type": "string"
        },
        "privateMaterial": {
          "description": "PrivateMaterial holds secret material (e.g. a private key, or symmetric token)",
          "type": "string",
          "format": "byte"
        },
        "publicMaterial": {
          "description": "PublicMaterial holds non-secret material (e.g. a certificate)",
          "type": "string",
          "format": "byte"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KeysetList": {
      "description": "KeysetList is a list of Keysets",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.Keyset"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KeysetSpec": {
      "description": "KeysetSpec is the spec for a Keyset",
      "properties": {
        "keys": {
          "description": "Keys is the set of keys that make up the keyset",
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KeysetItem"
          }
        },
        "type": {
          "description": "Type is the type of the Keyset (PKI keypair, or secret token)",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KopeioAuthenticationSpec": {},
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KopeioNetworkingSpec": {
      "description": "KopeioNetworkingSpec declares that we want Kopeio networking"
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubeAPIServerConfig": {
      "description": "KubeAPIServerConfig defines the configuration for the kube api",
      "properties": {
        "address": {
          "description": "Address is the binding address for the kube api: Deprecated - use insecure-bind-address and bind-address",
          "type": "string"
        },
        "admissionControl": {
          "description": "Deprecated: AdmissionControl is a list of admission controllers to use",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "allowPrivileged": {
          "description": "AllowPrivileged indicates if we can run privileged containers",
          "type": "boolean"
        },
        "anonymousAuth": {
          "description": "AnonymousAuth indicates if anonymous authentication is permitted",
          "type": "boolean"
        },
        "apiServerCount": {
          "description": "APIServerCount is the number of api servers",
          "type": "integer",
          "format": "int32"
        },
        "auditLogFormat": {
          "description": "AuditLogFormat flag specifies the format type for audit log files.",
          "type": "string"
        },
        "auditLogMaxAge": {
          "description": "The maximum number of days to retain old audit log files based on the timestamp encoded in their filename.",
          "type": "integer",
          "format": "int32"
        },
        "auditLogMaxBackups": {
          "description": "The maximum number of old audit log files to retain.",
          "type": "integer",
          "format": "int32"
        },
        "auditLogMaxSize": {
          "description": "The maximum size in megabytes of the audit log file before it gets rotated. Defaults to 100MB.",
          "type": "integer",
          "format": "int32"
        },
        "auditLogPath": {
          "description": "If set, all requests coming to the apiserver will be logged to this file.",
          "type": "string"
        },
        "auditPolicyFile": {
          "description": "AuditPolicyFile is the full path to a advanced audit configuration file a.g. /srv/kubernetes/audit.conf",
          "type": "string"
        },
        "authenticationTokenWebhookCacheTtl": {
          "description": "The duration to cache responses from the webhook token authenticator. Default is 2m. (default 2m0s)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "authenticationTokenWebhookConfigFile": {
          "description": "File with webhook configuration for token authentication in kubeconfig format. The API server will query the remote service to determine authentication for bearer tokens.",
          "type": "string"
        },
        "authorizationMode": {
          "description": "AuthorizationMode is the authorization mode the kubeapi is running in",
          "type": "string"
        },
        "authorizationRbacSuperUser": {
          "description": "AuthorizationRBACSuperUser is the name of the superuser for default rbac",
          "type": "string"
        },
        "basicAuthFile": {
          "type": "string"
        },
        "bindAddress": {
          "description": "BindAddress is the binding address for the secure kubernetes API",
          "type": "string"
        },
        "clientCAFile": {
          "type": "string"
        },
        "cloudProvider": {
          "description": "CloudProvider is the name of the cloudProvider we are using, aws, gce etcd",
          "type": "string"
        },
        "disableAdmissionPlugins": {
          "description": "DisableAdmissionPlugins is a list of disabled admission plugins",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "enableAdmissionPlugins": {
          "description": "EnableAdmissionPlugins is a list of enabled admission plugins",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "enableAggregatorRouting": {
          "description": "EnableAggregatorRouting enables aggregator routing requests to endpoints IP rather than cluster IP",
          "type": "boolean"
        },
        "enableBootstrapTokenAuth": {
          "description": "EnableBootstrapAuthToken enables 'bootstrap.kubernetes.io/token' in the 'kube-system' namespace to be used for TLS bootstrapping authentication",
          "type": "boolean"
        },
        "etcdCaFile": {
          "description": "EtcdCAFile is the path to a ca certificate",
          "type": "string"
        },
        "etcdCertFile": {
          "description": "EtcdCertFile is the path to a certificate",
          "type": "string"
        },
        "etcdKeyFile": {
          "description": "EtcdKeyFile is the path to a private key",
          "type": "string"
        },
        "etcdQuorumRead": {
          "description": "EtcdQuorumRead configures the etcd-quorum-read flag, which forces consistent reads from etcd",
          "type": "boolean"
        },
        "etcdServers": {
          "description": "EtcdServers is a list of the etcd service to connect",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "etcdServersOverrides": {
          "description": "EtcdServersOverrides is per-resource etcd servers overrides, comma separated. The individual override format: group/resource#servers, where servers are http://ip:port, semicolon separated",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "experimentalEncryptionProviderConfig": {
          "description": "ExperimentalEncryptionProviderConfig enables encryption at rest for secrets.",
          "type": "string"
        },
        "featureGates": {
          "description": "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "image": {
          "description": "Image is the docker container used",
          "type": "string"
        },
        "insecureBindAddress": {
          "description": "InsecureBindAddress is the binding address for the InsecurePort for the insecure kubernetes API",
          "type": "string"
        },
        "insecurePort": {
          "description": "InsecurePort is the port the insecure api runs",
          "type": "integer",
          "format": "int32"
        },
        "kubeletClientCertificate": {
          "description": "KubeletClientCertificate is the path of a certificate for secure communication between api and kubelet",
          "type": "string"
        },
        "kubeletClientKey": {
          "description": "KubeletClientKey is the path of a private to secure communication between api and kubelet",
          "type": "string"
        },
        "kubeletPreferredAddressTypes": {
          "description": "KubeletPreferredAddressTypes is a list of the preferred NodeAddressTypes to use for kubelet connections",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "logLevel": {
          "description": "LogLevel is the logging level of the api",
          "type": "integer",
          "format": "int32"
        },
        "maxRequestsInflight": {
          "description": "MaxRequestsInflight The maximum number of non-mutating requests in flight at a given time.",
          "type": "integer",
          "format": "int32"
        },
        "minRequestTimeout": {
          "description": "MinRequestTimeout configures the minimum number of seconds a handler must keep a request open before timing it out. Currently only honored by the watch request handler",
          "type": "integer",
          "format": "int32"
        },
        "oidcCAFile": {
          "description": "OIDCCAFile if set, the OpenID server's certificate will be verified by one of the authorities in the oidc-ca-file",
          "type": "string"
        },
        "oidcClientID": {
          "description": "OIDCClientID is the client ID for the OpenID Connect client, must be set if oidc-issuer-url is set.",
          "type": "string"
        },
        "oidcGroupsClaim": {
          "description": "OIDCGroupsClaim if provided, the name of a custom OpenID Connect claim for specifying user groups. The claim value is expected to be a string or array of strings.",
          "type": "string"
        },
        "oidcGroupsPrefix": {
          "description": "OIDCGroupsPrefix is the prefix prepended to group claims to prevent clashes with existing names (such as 'system:' groups)",
          "type": "string"
        },
        "oidcIssuerURL": {
          "description": "OIDCIssuerURL is the URL of the OpenID issuer, only HTTPS scheme will be accepted. If set, it will be used to verify the OIDC JSON Web Token (JWT).",
          "type": "string"
        },
        "oidcUsernameClaim": {
          "description": "OIDCUsernameClaim is the OpenID claim to use as the user name. Note that claims other than the default ('sub') is not guaranteed to be unique and immutable.",
          "type": "string"
        },
        "oidcUsernamePrefix": {
          "description": "OIDCUsernamePrefix is the prefix prepended to username claims to prevent clashes with existing names (such as 'system:' users).",
          "type": "string"
        },
        "proxyClientCertFile": {
          "description": "The apiserver's client certificate used for outbound requests.",
          "type": "string"
        },
        "proxyClientKeyFile": {
          "description": "The apiserver's client key used for outbound requests.",
          "type": "string"
        },
        "requestheaderAllowedNames": {
          "description": "List of client certificate common names to allow to provide usernames in headers specified by --requestheader-username-headers. If empty, any client certificate validated by the authorities in --requestheader-client-ca-file is allowed.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "requestheaderClientCAFile": {
          "description": "Root certificate bundle to use to verify client certificates on incoming requests before trusting usernames in headers specified by --requestheader-username-headers",
          "type": "string"
        },
        "requestheaderExtraHeaderPrefixes": {
          "description": "List of request header prefixes to inspect. X-Remote-Extra- is suggested.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "requestheaderGroupHeaders": {
          "description": "List of request headers to inspect for groups. X-Remote-Group is suggested.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "requestheaderUsernameHeaders": {
          "description": "List of request headers to inspect for usernames. X-Remote-User is common.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "runtimeConfig": {
          "description": "RuntimeConfig is a series of keys/values are parsed into the `--runtime-config` parameters",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "securePort": {
          "description": "SecurePort is the port the kube runs on",
          "type": "integer",
          "format": "int32"
        },
        "serviceClusterIPRange": {
          "description": "ServiceClusterIPRange is the service address range",
          "type": "string"
        },
        "serviceNodePortRange": {
          "description": "Passed as --service-node-port-range to kube-apiserver. Expects 'startPort-endPort' format. Eg. 30000-33000",
          "type": "string"
        },
        "storageBackend": {
          "description": "StorageBackend is the backend storage",
          "type": "string"
        },
        "tlsCertFile": {
          "type": "string"
        },
        "tlsPrivateKeyFile": {
          "type": "string"
        },
        "tokenAuthFile": {
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubeControllerManagerConfig": {
      "description": "KubeControllerManagerConfig is the configuration for the controller",
      "properties": {
        "allocateNodeCIDRs": {
          "description": "AllocateNodeCIDRs enables CIDRs for Pods to be allocated and, if ConfigureCloudRoutes is true, to be set on the cloud provider.",
          "type": "boolean"
        },
        "attachDetachReconcileSyncPeriod": {
          "description": "ReconcilerSyncLoopPeriod is the amount of time the reconciler sync states loop wait between successive executions. Is set to 1 min by kops by default",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "cidrAllocatorType": {
          "description": "CIDRAllocatorType specifies the type of CIDR allocator to use.",
          "type": "string"
        },
        "cloudProvider": {
          "description": "CloudProvider is the provider for cloud services.",
          "type": "string"
        },
        "clusterCIDR": {
          "description": "ClusterCIDR is CIDR Range for Pods in cluster.",
          "type": "string"
        },
        "clusterName": {
          "description": "ClusterName is the instance prefix for the cluster.",
          "type": "string"
        },
        "configureCloudRoutes": {
          "description": "ConfigureCloudRoutes enables CIDRs allocated with to be configured on the cloud provider.",
          "type": "boolean"
        },
        "featureGates": {
          "description": "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "horizontalPodAutoscalerDownscaleDelay": {
          "description": "HorizontalPodAutoscalerDownscaleDelay is a duration that specifies how long the autoscaler has to wait before another downscale operation can be performed after the current one has completed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "horizontalPodAutoscalerSyncPeriod": {
          "description": "HorizontalPodAutoscalerSyncPeriod is the amount of time between syncs During each period, the controller manager queries the resource utilization against the metrics specified in each HorizontalPodAutoscaler definition.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "horizontalPodAutoscalerUpscaleDelay": {
          "description": "HorizontalPodAutoscalerUpscaleDelay is a duration that specifies how long the autoscaler has to wait before another upscale operation can be performed after the current one has completed.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "horizontalPodAutoscalerUseRestClients": {
          "description": "HorizontalPodAutoscalerUseRestClients determines if the new-style clients should be used if support for custom metrics is enabled.",
          "type": "boolean"
        },
        "image": {
          "description": "Image is the docker image to use",
          "type": "string"
        },
        "leaderElection": {
          "description": "LeaderElection defines the configuration of leader election client.",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.LeaderElectionConfiguration"
        },
        "logLevel": {
          "description": "LogLevel is the defined logLevel",
          "type": "integer",
          "format": "int32"
        },
        "master": {
          "description": "Master is the url for the kube api master",
          "type": "string"
        },
        "nodeCIDRMaskSize": {
          "description": "NodeCIDRMaskSize set the size for the mask of the nodes.",
          "type": "integer",
          "format": "int32"
        },
        "nodeMonitorGracePeriod": {
          "description": "NodeMonitorGracePeriod is the amount of time which we allow running Node to be unresponsive before marking it unhealthy. (default 40s) Must be N-1 times more than kubelet's nodeStatusUpdateFrequency, where N means number of retries allowed for kubelet to post node status.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "nodeMonitorPeriod": {
          "description": "NodeMonitorPeriod is the period for syncing NodeStatus in NodeController. (default 5s)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "podEvictionTimeout": {
          "description": "PodEvictionTimeout is the grace period for deleting pods on failed nodes. (default 5m0s)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "rootCAFile": {
          "description": "rootCAFile is the root certificate authority will be included in service account's token secret. This must be a valid PEM-encoded CA bundle.",
          "type": "string"
        },
        "serviceAccountPrivateKeyFile": {
          "description": "ServiceAccountPrivateKeyFile the location for a certificate for service account signing",
          "type": "string"
        },
        "terminatedPodGCThreshold": {
          "description": "TerminatedPodGCThreshold is the number of terminated pods that can exist before the terminated pod garbage collector starts deleting terminated pods. If \u003c= 0, the terminated pod garbage collector is disabled.",
          "type": "integer",
          "format": "int32"
        },
        "useServiceAccountCredentials": {
          "description": "UseServiceAccountCredentials controls whether we use individual service account credentials for each controller.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubeDNSConfig": {
      "description": "KubeDNSConfig defines the kube dns configuration",
      "properties": {
        "cacheMaxConcurrent": {
          "description": "CacheMaxConcurrent is the maximum number of concurrent queries for dnsmasq",
          "type": "integer",
          "format": "int32"
        },
        "cacheMaxSize": {
          "description": "CacheMaxSize is the maximum entries to keep in dnsmaq",
          "type": "integer",
          "format": "int32"
        },
        "domain": {
          "description": "Domain is the dns domain",
          "type": "string"
        },
        "image": {
          "description": "Image is the name of the docker image to run - @deprecated as this is now in the addon",
          "type": "string"
        },
        "provider": {
          "description": "Provider indicates whether CoreDNS or kube-dns will be the default service discovery.",
          "type": "string"
        },
        "replicas": {
          "description": "Replicas is the number of pod replicas - @deprecated as this is now in the addon, and controlled by autoscaler",
          "type": "integer",
          "format": "int32"
        },
        "serverIP": {
          "description": "ServerIP is the server ip",
          "type": "string"
        },
        "stubDomains": {
          "description": "StubDomains redirects a domains to another DNS service",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "upstreamNameservers": {
          "description": "UpstreamNameservers sets the upstream nameservers for queries not on the cluster domain",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubeProxyConfig": {
      "description": "KubeProxyConfig defines the configuration for a proxy",
      "properties": {
        "bindAddress": {
          "description": "BindAddress is IP address for the proxy server to serve on",
          "type": "string"
        },
        "clusterCIDR": {
          "description": "ClusterCIDR is the CIDR range of the pods in the cluster",
          "type": "string"
        },
        "conntrackMaxPerCore": {
          "description": "Maximum number of NAT connections to track per CPU core (default: 131072)",
          "type": "integer",
          "format": "int32"
        },
        "conntrackMin": {
          "description": "Minimum number of conntrack entries to allocate, regardless of conntrack-max-per-core",
          "type": "integer",
          "format": "int32"
        },
        "cpuLimit": {
          "description": "CPULimit, cpu limit compute resource for kube proxy e.g. \"30m\"",
          "type": "string"
        },
        "cpuRequest": {
          "description": "CPURequest, cpu request compute resource for kube proxy e.g. \"20m\"",
          "type": "string"
        },
        "enabled": {
          "description": "Enabled allows enabling or disabling kube-proxy",
          "type": "boolean"
        },
        "featureGates": {
          "description": "FeatureGates is a series of key pairs used to switch on features for the proxy",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "hostnameOverride": {
          "description": "HostnameOverride, if non-empty, will be used as the identity instead of the actual hostname.",
          "type": "string"
        },
        "image": {
          "type": "string"
        },
        "logLevel": {
          "description": "LogLevel is the logging level of the proxy",
          "type": "integer",
          "format": "int32"
        },
        "master": {
          "description": "Master is the address of the Kubernetes API server (overrides any value in kubeconfig)",
          "type": "string"
        },
        "memoryLimit": {
          "description": "MemoryLimit, memory limit compute resource for kube proxy e.g. \"30Mi\"",
          "type": "string"
        },
        "memoryRequest": {
          "description": "MemoryRequest, memory request compute resource for kube proxy e.g. \"30Mi\"",
          "type": "string"
        },
        "proxyMode": {
          "description": "Which proxy mode to use: (userspace, iptables, ipvs)",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubeSchedulerConfig": {
      "description": "KubeSchedulerConfig is the configuration for the kube-scheduler",
      "properties": {
        "featureGates": {
          "description": "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "image": {
          "description": "Image is the docker image to use",
          "type": "string"
        },
        "leaderElection": {
          "description": "LeaderElection defines the configuration of leader election client.",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.LeaderElectionConfiguration"
        },
        "logLevel": {
          "description": "LogLevel is the logging level",
          "type": "integer",
          "format": "int32"
        },
        "master": {
          "description": "Master is a url to the kube master",
          "type": "string"
        },
        "usePolicyConfigMap": {
          "description": "UsePolicyConfigMap enable setting the scheduler policy from a configmap",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubeletConfigSpec": {
      "description": "KubeletConfigSpec defines the kubelet configuration",
      "properties": {
        "allowPrivileged": {
          "description": "AllowPrivileged enables containers to request privileged mode (defaults to false)",
          "type": "boolean"
        },
        "anonymousAuth": {
          "description": "AnonymousAuth permits you to control auth to the kubelet api",
          "type": "boolean"
        },
        "apiServers": {
          "description": "APIServers is not used for clusters version 1.6 and later - flag removed",
          "type": "string"
        },
        "authenticationTokenWebhook": {
          "description": "AuthenticationTokenWebhook uses the TokenReview API to determine authentication for bearer tokens.",
          "type": "boolean"
        },
        "authenticationTokenWebhookCacheTtl": {
          "description": "AuthenticationTokenWebhook sets the duration to cache responses from the webhook token authenticator. Default is 2m. (default 2m0s)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "authorizationMode": {
          "description": "AuthorizationMode is the authorization mode the kubelet is running in",
          "type": "string"
        },
        "babysitDaemons": {
          "description": "The node has babysitter process monitoring docker and kubelet. Removed as of 1.7",
          "type": "boolean"
        },
        "bootstrapKubeconfig": {
          "description": "BootstrapKubeconfig is the path to a kubeconfig file that will be used to get client certificate for kubelet",
          "type": "string"
        },
        "cgroupRoot": {
          "description": "cgroupRoot is the root cgroup to use for pods. This is handled by the container runtime on a best effort basis.",
          "type": "string"
        },
        "clientCaFile": {
          "description": "ClientCAFile is the path to a CA certificate",
          "type": "string"
        },
        "cloudProvider": {
          "description": "CloudProvider is the provider for cloud services.",
          "type": "string"
        },
        "clusterDNS": {
          "description": "ClusterDNS is the IP address for a cluster DNS server",
          "type": "string"
        },
        "clusterDomain": {
          "description": "ClusterDomain is the DNS domain for this cluster",
          "type": "string"
        },
        "configureCbr0": {
          "description": "configureCBR0 enables the kublet to configure cbr0 based on Node.Spec.PodCIDR.",
          "type": "boolean"
        },
        "dockerDisableSharedPID": {
          "description": "DockerDisableSharedPID uses a shared PID namespace for containers in a pod.",
          "type": "boolean"
        },
        "enableCustomMetrics": {
          "description": "Enable gathering custom metrics.",
          "type": "boolean"
        },
        "enableDebuggingHandlers": {
          "description": "EnableDebuggingHandlers enables server endpoints for log collection and local running of containers and commands",
          "type": "boolean"
        },
        "enforceNodeAllocatable": {
          "description": "Enforce Allocatable across pods whenever the overall usage across all pods exceeds Allocatable.",
          "type": "string"
        },
        "evictionHard": {
          "description": "Comma-delimited list of hard eviction expressions.  For example, 'memory.available\u003c300Mi'.",
          "type": "string"
        },
        "evictionMaxPodGracePeriod": {
          "description": "Maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.",
          "type": "integer",
          "format": "int32"
        },
        "evictionMinimumReclaim": {
          "description": "Comma-delimited list of minimum reclaims (e.g. imagefs.available=2Gi) that describes the minimum amount of resource the kubelet will reclaim when performing a pod eviction if that resource is under pressure.",
          "type": "string"
        },
        "evictionPressureTransitionPeriod": {
          "description": "Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "evictionSoft": {
          "description": "Comma-delimited list of soft eviction expressions.  For example, 'memory.available\u003c300Mi'.",
          "type": "string"
        },
        "evictionSoftGracePeriod": {
          "description": "Comma-delimited list of grace periods for each soft eviction signal.  For example, 'memory.available=30s'.",
          "type": "string"
        },
        "experimental_allowed_unsafe_sysctls": {
          "description": "ExperimentalAllowedUnsafeSysctls are passed to the kubelet config to whitelist allowable sysctls",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "failSwapOn": {
          "description": "Tells the Kubelet to fail to start if swap is enabled on the node.",
          "type": "boolean"
        },
        "featureGates": {
          "description": "FeatureGates is set of key=value pairs that describe feature gates for alpha/experimental features.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "hairpinMode": {
          "description": "How should the kubelet configure the container bridge for hairpin packets. Setting this flag allows endpoints in a Service to loadbalance back to themselves if they should try to access their own Service. Values:\n  \"promiscuous-bridge\": make the container bridge promiscuous.\n  \"hairpin-veth\":       set the hairpin flag on container veth interfaces.\n  \"none\":               do nothing.\nSetting --configure-cbr0 to false implies that to achieve hairpin NAT one must set --hairpin-mode=veth-flag, because bridge assumes the existence of a container bridge named cbr0.",
          "type": "string"
        },
        "hostnameOverride": {
          "description": "HostnameOverride is the hostname used to identify the kubelet instead of the actual hostname.",
          "type": "string"
        },
        "imageGCHighThresholdPercent": {
          "description": "ImageGCHighThresholdPercent is the percent of disk usage after which image garbage collection is always run.",
          "type": "integer",
          "format": "int32"
        },
        "imageGCLowThresholdPercent": {
          "description": "ImageGCLowThresholdPercent is the percent of disk usage before which image garbage collection is never run. Lowest disk usage to garbage collect to.",
          "type": "integer",
          "format": "int32"
        },
        "imagePullProgressDeadline": {
          "description": "ImagePullProgressDeadline is the timeout for image pulls If no pulling progress is made before this deadline, the image pulling will be cancelled. (default 1m0s)",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "kubeReserved": {
          "description": "Resource reservation for kubernetes system daemons like the kubelet, container runtime, node problem detector, etc.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "kubeReservedCgroup": {
          "description": "Control group for kube daemons.",
          "type": "string"
        },
        "kubeconfigPath": {
          "description": "KubeconfigPath is the path of kubeconfig for the kubelet",
          "type": "string"
        },
        "kubeletCgroups": {
          "description": "KubeletCgroups is the absolute name of cgroups to isolate the kubelet in.",
          "type": "string"
        },
        "logLevel": {
          "description": "LogLevel is the logging level of the kubelet",
          "type": "integer",
          "format": "int32"
        },
        "maxPods": {
          "description": "MaxPods is the number of pods that can run on this Kubelet.",
          "type": "integer",
          "format": "int32"
        },
        "networkPluginMTU": {
          "description": "NetworkPluginMTU is the MTU to be passed to the network plugin, and overrides the default MTU for cases where it cannot be automatically computed (such as IPSEC).",
          "type": "integer",
          "format": "int32"
        },
        "networkPluginName": {
          "description": "NetworkPluginName is the name of the network plugin to be invoked for various events in kubelet/pod lifecycle",
          "type": "string"
        },
        "nodeLabels": {
          "description": "NodeLabels to add when registering the node in the cluster.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "nodeStatusUpdateFrequency": {
          "description": "NodeStatusUpdateFrequency Specifies how often kubelet posts node status to master (default 10s) must work with nodeMonitorGracePeriod in KubeControllerManagerConfig.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "nonMasqueradeCIDR": {
          "description": "NonMasqueradeCIDR configures masquerading: traffic to IPs outside this range will use IP masquerade.",
          "type": "string"
        },
        "nvidiaGPUs": {
          "description": "NvidiaGPUs is the number of NVIDIA GPU devices on this node.",
          "type": "integer",
          "format": "int32"
        },
        "podCIDR": {
          "description": "PodCIDR is the CIDR to use for pod IP addresses, only used in standalone mode. In cluster mode, this is obtained from the master.",
          "type": "string"
        },
        "podInfraContainerImage": {
          "description": "PodInfraContainerImage is the image whose network/ipc containers in each pod will use.",
          "type": "string"
        },
        "podManifestPath": {
          "description": "config is the path to the config file or directory of files",
          "type": "string"
        },
        "readOnlyPort": {
          "description": "ReadOnlyPort is the port used by the kubelet api for read-only access (default 10255)",
          "type": "integer",
          "format": "int32"
        },
        "reconcileCIDR": {
          "description": "ReconcileCIDR is Reconcile node CIDR with the CIDR specified by the API server. No-op if register-node or configure-cbr0 is false.",
          "type": "boolean"
        },
        "registerNode": {
          "description": "RegisterNode enables automatic registration with the apiserver.",
          "type": "boolean"
        },
        "registerSchedulable": {
          "description": "registerSchedulable tells the kubelet to register the node as schedulable. No-op if register-node is false.",
          "type": "boolean"
        },
        "requireKubeconfig": {
          "description": "RequireKubeconfig indicates a kubeconfig is required",
          "type": "boolean"
        },
        "resolvConf": {
          "description": "ResolverConfig is the resolver configuration file used as the basis for the container DNS resolution configuration.\"), []",
          "type": "string"
        },
        "rootDir": {
          "description": "RootDir is the directory path for managing kubelet files (volume mounts,etc)",
          "type": "string"
        },
        "runtimeCgroups": {
          "description": "Cgroups that container runtime is expected to be isolated in.",
          "type": "string"
        },
        "runtimeRequestTimeout": {
          "description": "RuntimeRequestTimeout is timeout for runtime requests on - pull, logs, exec and attach",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "seccompProfileRoot": {
          "description": "SeccompProfileRoot is the directory path for seccomp profiles.",
          "type": "string"
        },
        "serializeImagePulls": {
          "description": "// SerializeImagePulls when enabled, tells the Kubelet to pull images one // at a time. We recommend *not* changing the default value on nodes that // run docker daemon with version  \u003c 1.9 or an Aufs storage backend. // Issue #10959 has more details.",
          "type": "boolean"
        },
        "streamingConnectionIdleTimeout": {
          "description": "StreamingConnectionIdleTimeout is the maximum time a streaming connection can be idle before the connection is automatically closed",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "systemCgroups": {
          "description": "SystemCgroups is absolute name of cgroups in which to place all non-kernel processes that are not already in a container. Empty for no container. Rolling back the flag requires a reboot.",
          "type": "string"
        },
        "systemReserved": {
          "description": "Capture resource reservation for OS system daemons like sshd, udev, etc.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "systemReservedCgroup": {
          "description": "Parent control group for OS system daemons.",
          "type": "string"
        },
        "taints": {
          "description": "Taints to add when registering a node in the cluster",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tlsCertFile": {
          "type": "string"
        },
        "tlsPrivateKeyFile": {
          "type": "string"
        },
        "volumePluginDirectory": {
          "description": "The full path of the directory in which to search for additional third party volume plugins",
          "type": "string"
        },
        "volumeStatsAggPeriod": {
          "description": "VolumeStatsAggPeriod is the interval for kubelet to calculate and cache the volume disk usage for all pods and volumes",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KubenetNetworkingSpec": {
      "description": "KubenetNetworkingSpec is the specification for kubenet networking, largely integrated but intended to replace classic"
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.KuberouterNetworkingSpec": {
      "description": "KuberouterNetworkingSpec declares that we want Kube-router networking"
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.LeaderElectionConfiguration": {
      "description": "LeaderElectionConfiguration defines the configuration of leader election clients for components that can run with leader election enabled.",
      "properties": {
        "leaderElect": {
          "description": "leaderElect enables a leader election client to gain leadership before executing the main loop. Enable this when running replicated components for high availability.",
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.LoadBalancer": {
      "description": "LoadBalancer defines a load balancer",
      "properties": {
        "loadBalancerName": {
          "description": "LoadBalancerName to associate with this instance group (AWS ELB)",
          "type": "string"
        },
        "targetGroupArn": {
          "description": "TargetGroupARN to associate with this instance group (AWS ALB/NLB)",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.LoadBalancerAccessSpec": {
      "description": "LoadBalancerAccessSpec provides configuration details related to API LoadBalancer and its access",
      "properties": {
        "additionalSecurityGroups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "idleTimeoutSeconds": {
          "type": "integer",
          "format": "int64"
        },
        "sslCertificate": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "useForInternalApi": {
          "type": "boolean"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.NetworkingSpec": {
      "description": "NetworkingSpec allows selection and configuration of a networking plugin",
      "properties": {
        "amazonvpc": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.AmazonVPCNetworkingSpec"
        },
        "calico": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.CalicoNetworkingSpec"
        },
        "canal": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.CanalNetworkingSpec"
        },
        "cilium": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.CiliumNetworkingSpec"
        },
        "classic": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.ClassicNetworkingSpec"
        },
        "cni": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.CNINetworkingSpec"
        },
        "external": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.ExternalNetworkingSpec"
        },
        "flannel": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.FlannelNetworkingSpec"
        },
        "kopeio": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KopeioNetworkingSpec"
        },
        "kubenet": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KubenetNetworkingSpec"
        },
        "kuberouter": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.KuberouterNetworkingSpec"
        },
        "romana": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.RomanaNetworkingSpec"
        },
        "weave": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.WeaveNetworkingSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.NodeAuthorizationSpec": {
      "description": "NodeAuthorizationSpec is used to node authorization",
      "properties": {
        "nodeAuthorizer": {
          "description": "NodeAuthorizer defined the configuration for the node authorizer",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.NodeAuthorizerSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.NodeAuthorizerSpec": {
      "description": "NodeAuthorizerSpec defines the configuration for a node authorizer",
      "properties": {
        "authorizer": {
          "description": "Authorizer is the authorizer to use",
          "type": "string"
        },
        "features": {
          "description": "Features is a series of authorizer features to enable or disable",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "image": {
          "description": "Image is the location of container",
          "type": "string"
        },
        "nodeURL": {
          "description": "NodeURL is the node authorization service url",
          "type": "string"
        },
        "port": {
          "description": "Port is the port the service is running on the master",
          "type": "integer",
          "format": "int32"
        },
        "timeout": {
          "description": "Timeout the max time for authorization request",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        },
        "tokenTTL": {
          "description": "TokenTTL is the max ttl for an issued token",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Duration"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.RBACAuthorizationSpec": {},
    "io.k8s.kops.pkg.apis.kops.v1alpha2.RomanaNetworkingSpec": {
      "description": "RomanaNetworkingSpec declares that we want Romana networking",
      "properties": {
        "daemonServiceIP": {
          "description": "DaemonServiceIP is the Kubernetes Service IP for the romana-daemon pod",
          "type": "string"
        },
        "etcdServiceIP": {
          "description": "EtcdServiceIP is the Kubernetes Service IP for the etcd backend used by Romana",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.SSHCredential": {
      "description": "SSHCredential represent a set of kops secrets",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.SSHCredentialSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.SSHCredentialList": {
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.SSHCredential"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.SSHCredentialSpec": {
      "properties": {
        "publicKey": {
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.TargetSpec": {
      "description": "TargetSpec allows for specifying target config in an extensible way",
      "properties": {
        "terraform": {
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.TerraformSpec"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.TerraformSpec": {
      "description": "TerraformSpec allows us to specify terraform config in an extensible way",
      "properties": {
        "providerExtraConfig": {
          "description": "ProviderExtraConfig contains key/value pairs to add to the rendered terraform \"provider\" block",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.TopologySpec": {
      "properties": {
        "bastion": {
          "description": "Bastion provide an external facing point of entry into a network containing private network instances. This host can provide a single point of fortification or audit and can be started and stopped to enable or disable inbound SSH communication from the Internet, some call bastion as the \"jump server\".",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.BastionSpec"
        },
        "dns": {
          "description": "DNS configures options relating to DNS, in particular whether we use a public or a private hosted zone",
          "$ref": "#/definitions/io.k8s.kops.pkg.apis.kops.v1alpha2.DNSSpec"
        },
        "masters": {
          "description": "The environment to launch the Kubernetes masters in public|private",
          "type": "string"
        },
        "nodes": {
          "description": "The environment to launch the Kubernetes nodes in public|private",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.UserData": {
      "description": "UserData defines a user-data section",
      "properties": {
        "content": {
          "description": "Content is the user-data content",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of the user-data",
          "type": "string"
        },
        "type": {
          "description": "Type is the type of user-data",
          "type": "string"
        }
      }
    },
    "io.k8s.kops.pkg.apis.kops.v1alpha2.WeaveNetworkingSpec": {
      "description": "WeaveNetworkingSpec declares that we want Weave networking",
      "properties": {
        "connLimit": {
          "type": "integer",
          "format": "int32"
        },
        "mtu": {
          "type": "integer",
          "format": "int32"
        }
      }
    }
  }
}
